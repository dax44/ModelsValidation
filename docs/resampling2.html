<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="pl" xml:lang="pl"><head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.549">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<title>Metody walidacji modeli statystycznych - 7&nbsp; Metody próbkowania</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>

<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./comparison.html" rel="next">
<link href="./tidymodels.html" rel="prev">
<link href="./cover.png" rel="icon" type="image/png">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="site_libs/bootstrap/bootstrap-dark.min.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script src="site_libs/quarto-contrib/glightbox/glightbox.min.js"></script>
<link href="site_libs/quarto-contrib/glightbox/glightbox.min.css" rel="stylesheet">
<link href="site_libs/quarto-contrib/glightbox/lightbox.css" rel="stylesheet"><script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "Brak wyników",
    "search-matching-documents-text": "dopasowane dokumenty",
    "search-copy-link-title": "Kopiuj link do wyszukiwania",
    "search-hide-matches-text": "Ukryj dodatkowe dopasowania",
    "search-more-match-text": "więcej dopasowań w tym dokumencie",
    "search-more-matches-text": "więcej dopasowań w tym dokumencie",
    "search-clear-button-title": "Wyczyść",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Anuluj",
    "search-submit-button-title": "Zatwierdź",
    "search-label": "Szukaj"
  }
}</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script><script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>
</head>
<body class="nav-sidebar floating slimcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top"><nav class="quarto-secondary-nav"><div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Przełącz pasek boczny" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./resampling2.html"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Metody próbkowania</span></a></li></ol></nav>
        <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Przełącz pasek boczny" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav></header><!-- content --><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto"><div class="pt-lg-2 mt-2 text-left sidebar-header sidebar-header-stacked">
      <a href="./index.html" class="sidebar-logo-link">
      <img src="./images/logo.png" alt="" class="sidebar-logo py-0 d-lg-inline d-none"></a>
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Metody walidacji modeli statystycznych</a> 
        <div class="sidebar-tools-main tools-wide">
    <a href="https://twitter.com" title="" class="quarto-navigation-tool px-1" aria-label=""><i class="bi bi-twitter"></i></a>
    <a href="https://github.com/dax44/ModelsValidation/" title="Source Code" class="quarto-navigation-tool px-1" aria-label="Source Code"><i class="bi bi-github"></i></a>
    <a href="https://twitter.com/intent/tweet?url=%7Curl%7C" title="Twitter" class="quarto-navigation-tool px-1" aria-label="Twitter"><i class="bi bi-twitter"></i></a>
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Przełącz tryb ciemny"><i class="bi"></i></a>
  <a href="" class="quarto-reader-toggle quarto-navigation-tool px-1" onclick="window.quartoToggleReader(); return false;" title="Przełącz tryb czytnika">
  <div class="quarto-reader-toggle-btn">
  <i class="bi"></i>
  </div>
</a>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Szukaj"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
<li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Wprowadzenie</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./intro.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Ekosystem</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./modeling.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Modelowanie statystyczne</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./infer.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Modele inferencyjne</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./measures.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Przegląd miar dopasowania modelu</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./resampling.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Zarządzanie danymi</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./tidymodels.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Praca z <code>tidymodels</code></span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./resampling2.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Metody próbkowania</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./comparison.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Porównanie modeli</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./tuning.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">Optymalizacja modeli</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./grid_search.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">Dostrajanie z przeszukiwaniem siatki</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./parallel.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">11</span>&nbsp; <span class="chapter-title">Paralelizacja resamplingu</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./iterative.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">12</span>&nbsp; <span class="chapter-title">Przeszukiwanie iteracyjne</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./example.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">13</span>&nbsp; <span class="chapter-title">Poszukiwanie optymalnego modelu</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./dimensionality.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">14</span>&nbsp; <span class="chapter-title">Redukcja wymiarowości</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./imbalance.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">15</span>&nbsp; <span class="chapter-title">Nierównowaga klas w zadaniu klasyfikacyjnym</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./references.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">References</span></a>
  </div>
</li>
    </ul>
</div>
</nav><div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active"><h2 id="toc-title">Spis treści</h2>
   
  <ul>
<li><a href="#walidacja-krzy%C5%BCowa" id="toc-walidacja-krzyżowa" class="nav-link active" data-scroll-target="#walidacja-krzy%C5%BCowa"><span class="header-section-number">7.1</span> Walidacja krzyżowa</a></li>
  <li><a href="#sprawdzian-krzy%C5%BCowy-z-powt%C3%B3rzeniami" id="toc-sprawdzian-krzyżowy-z-powtórzeniami" class="nav-link" data-scroll-target="#sprawdzian-krzy%C5%BCowy-z-powt%C3%B3rzeniami"><span class="header-section-number">7.2</span> Sprawdzian krzyżowy z powtórzeniami</a></li>
  <li><a href="#leave-one-out" id="toc-leave-one-out" class="nav-link" data-scroll-target="#leave-one-out"><span class="header-section-number">7.3</span> Leave-One-Out</a></li>
  <li><a href="#walidacja-metod%C4%85-monte-carlo" id="toc-walidacja-metodą-monte-carlo" class="nav-link" data-scroll-target="#walidacja-metod%C4%85-monte-carlo"><span class="header-section-number">7.4</span> Walidacja metodą Monte-Carlo</a></li>
  <li><a href="#zbi%C3%B3r-walidacyjny" id="toc-zbiór-walidacyjny" class="nav-link" data-scroll-target="#zbi%C3%B3r-walidacyjny"><span class="header-section-number">7.5</span> Zbiór walidacyjny</a></li>
  <li><a href="#bootstrapping" id="toc-bootstrapping" class="nav-link" data-scroll-target="#bootstrapping"><span class="header-section-number">7.6</span> Bootstrapping</a></li>
  <li><a href="#krocz%C4%85ce-pr%C3%B3bkowanie-%C5%BAr%C3%B3d%C5%82a" id="toc-kroczące-próbkowanie-źródła" class="nav-link" data-scroll-target="#krocz%C4%85ce-pr%C3%B3bkowanie-%C5%BAr%C3%B3d%C5%82a"><span class="header-section-number">7.7</span> Kroczące próbkowanie źródła</a></li>
  <li><a href="#oszacowanie-dopasowania-z-wykorzystaniem-resamplingu" id="toc-oszacowanie-dopasowania-z-wykorzystaniem-resamplingu" class="nav-link" data-scroll-target="#oszacowanie-dopasowania-z-wykorzystaniem-resamplingu"><span class="header-section-number">7.8</span> Oszacowanie dopasowania z wykorzystaniem resamplingu</a></li>
  <li><a href="#przetwarzanie-r%C3%B3wnoleg%C5%82e" id="toc-przetwarzanie-równoległe" class="nav-link" data-scroll-target="#przetwarzanie-r%C3%B3wnoleg%C5%82e"><span class="header-section-number">7.9</span> Przetwarzanie równoległe</a></li>
  <li><a href="#przechowywanie-wynik%C3%B3w-resamplingu" id="toc-przechowywanie-wyników-resamplingu" class="nav-link" data-scroll-target="#przechowywanie-wynik%C3%B3w-resamplingu"><span class="header-section-number">7.10</span> Przechowywanie wyników resamplingu</a></li>
  </ul><div class="toc-actions"><ul><li><a href="https://github.com/dax44/ModelsValidation/issues/new" class="toc-action"><i class="bi bi-github"></i>Zgłoś problem</a></li></ul></div></nav>
    </div>
<!-- main -->
<main class="content page-columns page-full" id="quarto-document-content"><header id="title-block-header" class="quarto-title-block default"><div class="quarto-title">
<h1 class="title">
<span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Metody próbkowania</span>
</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header><p>W celu przedstawienia zasad próbkowania przytoczymy przykład z zestawem danych <code>ames</code>, na którym dokonywaliśmy już modelowania (regresja liniowa)<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>. Oprócz modelu liniowego zbudujemy również las losowy, który jest bardzo elastycznym modelem nie wymagającym wstępnego przetwarzania.</p>
<div class="no-row-height column-margin column-container"><p><sup>1</sup>&nbsp;z przykładu w poprzednim rozdziale</p></div><div id="exm-1" class="theorem example page-columns page-full">
<p><span class="theorem-title"><strong>Przykład 7.1</strong></span> &nbsp;</p>
<div class="cell">
<details open="" class="code-fold"><summary>Kod</summary><div class="sourceCode" id="cb1"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://tidymodels.tidymodels.org">tidymodels</a></span><span class="op">)</span></span>
<span><span class="fu"><a href="https://tidymodels.tidymodels.org/reference/tidymodels_prefer.html">tidymodels_prefer</a></span><span class="op">(</span><span class="op">)</span></span>
<span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/Random.html">set.seed</a></span><span class="op">(</span><span class="fl">44</span><span class="op">)</span></span>
<span><span class="va">ames</span> <span class="op">&lt;-</span> <span class="va">ames</span> <span class="op">|&gt;</span><span class="fu">mutate</span><span class="op">(</span>Sale_Price <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html">log10</a></span><span class="op">(</span><span class="va">Sale_Price</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">ames_split</span> <span class="op">&lt;-</span> <span class="fu">initial_split</span><span class="op">(</span><span class="va">ames</span>, prop <span class="op">=</span> <span class="fl">0.80</span>, strata <span class="op">=</span> <span class="va">Sale_Price</span><span class="op">)</span></span>
<span><span class="va">ames_train</span> <span class="op">&lt;-</span> <span class="fu">training</span><span class="op">(</span><span class="va">ames_split</span><span class="op">)</span></span>
<span><span class="va">ames_test</span>  <span class="op">&lt;-</span>  <span class="fu">testing</span><span class="op">(</span><span class="va">ames_split</span><span class="op">)</span></span>
<span></span>
<span><span class="va">lm_model</span> <span class="op">&lt;-</span> </span>
<span>  <span class="fu">linear_reg</span><span class="op">(</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>  <span class="fu">set_engine</span><span class="op">(</span><span class="st">"lm"</span><span class="op">)</span></span>
<span></span>
<span><span class="va">ames_rec</span> <span class="op">&lt;-</span> </span>
<span>  <span class="fu">recipe</span><span class="op">(</span><span class="va">Sale_Price</span> <span class="op">~</span> <span class="va">Neighborhood</span> <span class="op">+</span> <span class="va">Gr_Liv_Area</span> <span class="op">+</span> <span class="va">Year_Built</span> <span class="op">+</span> <span class="va">Bldg_Type</span> <span class="op">+</span> </span>
<span>           <span class="va">Latitude</span> <span class="op">+</span> <span class="va">Longitude</span>, data <span class="op">=</span> <span class="va">ames_train</span><span class="op">)</span> <span class="op">%&gt;%</span></span>
<span>  <span class="fu">step_log</span><span class="op">(</span><span class="va">Gr_Liv_Area</span>, base <span class="op">=</span> <span class="fl">10</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>  <span class="fu">step_other</span><span class="op">(</span><span class="va">Neighborhood</span>, threshold <span class="op">=</span> <span class="fl">0.01</span>, id <span class="op">=</span> <span class="st">"my_id"</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>  <span class="fu">step_dummy</span><span class="op">(</span><span class="fu">all_nominal_predictors</span><span class="op">(</span><span class="op">)</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>  <span class="fu">step_interact</span><span class="op">(</span> <span class="op">~</span> <span class="va">Gr_Liv_Area</span><span class="op">:</span><span class="fu">starts_with</span><span class="op">(</span><span class="st">"Bldg_Type_"</span><span class="op">)</span> <span class="op">)</span> <span class="op">|&gt;</span></span>
<span>  <span class="fu">step_ns</span><span class="op">(</span><span class="va">Latitude</span>, <span class="va">Longitude</span>, deg_free <span class="op">=</span> <span class="fl">20</span><span class="op">)</span></span>
<span></span>
<span><span class="va">lm_wflow</span> <span class="op">&lt;-</span> </span>
<span>  <span class="fu">workflow</span><span class="op">(</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>  <span class="fu">add_model</span><span class="op">(</span><span class="va">lm_model</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>  <span class="fu">add_recipe</span><span class="op">(</span><span class="va">ames_rec</span><span class="op">)</span></span>
<span></span>
<span><span class="va">lm_fit</span> <span class="op">&lt;-</span> <span class="fu">fit</span><span class="op">(</span><span class="va">lm_wflow</span>, <span class="va">ames_train</span><span class="op">)</span></span>
<span></span>
<span><span class="va">rf_model</span> <span class="op">&lt;-</span> </span>
<span>  <span class="fu">rand_forest</span><span class="op">(</span>trees <span class="op">=</span> <span class="fl">1000</span><span class="op">)</span> <span class="op">|&gt;</span> </span>
<span>  <span class="fu">set_engine</span><span class="op">(</span><span class="st">"ranger"</span><span class="op">)</span> <span class="op">|&gt;</span> </span>
<span>  <span class="fu">set_mode</span><span class="op">(</span><span class="st">"regression"</span><span class="op">)</span></span>
<span></span>
<span><span class="va">rf_wflow</span> <span class="op">&lt;-</span> </span>
<span>  <span class="fu">workflow</span><span class="op">(</span><span class="op">)</span> <span class="op">|&gt;</span> </span>
<span>  <span class="fu">add_formula</span><span class="op">(</span></span>
<span>    <span class="va">Sale_Price</span> <span class="op">~</span> <span class="va">Neighborhood</span> <span class="op">+</span> <span class="va">Gr_Liv_Area</span> <span class="op">+</span> <span class="va">Year_Built</span> <span class="op">+</span> <span class="va">Bldg_Type</span> <span class="op">+</span> </span>
<span>      <span class="va">Latitude</span> <span class="op">+</span> <span class="va">Longitude</span><span class="op">)</span> <span class="op">|&gt;</span> </span>
<span>  <span class="fu">add_model</span><span class="op">(</span><span class="va">rf_model</span><span class="op">)</span> </span>
<span></span>
<span><span class="va">rf_fit</span> <span class="op">&lt;-</span> <span class="va">rf_wflow</span> <span class="op">|&gt;</span> <span class="fu">fit</span><span class="op">(</span>data <span class="op">=</span> <span class="va">ames_train</span><span class="op">)</span></span></code><button title="Kopiuj do schowka" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Ponieważ kilkukrotnie będziemy wywoływać podsumowanie modeli za pomocą metryk, to stworzymy funkcję, którą będziemy mogli stosować wielokrotnie.</p>
<div class="cell">
<details open="" class="code-fold"><summary>Kod</summary><div class="sourceCode" id="cb2"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">estimate_perf</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">model</span>, <span class="va">dat</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="co"># Capture the names of the `model` and `dat` objects</span></span>
<span>  <span class="va">cl</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/match.call.html">match.call</a></span><span class="op">(</span><span class="op">)</span></span>
<span>  <span class="va">obj_name</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/character.html">as.character</a></span><span class="op">(</span><span class="va">cl</span><span class="op">$</span><span class="va">model</span><span class="op">)</span></span>
<span>  <span class="va">data_name</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/character.html">as.character</a></span><span class="op">(</span><span class="va">cl</span><span class="op">$</span><span class="va">dat</span><span class="op">)</span></span>
<span>  <span class="va">data_name</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/grep.html">gsub</a></span><span class="op">(</span><span class="st">"ames_"</span>, <span class="st">""</span>, <span class="va">data_name</span><span class="op">)</span></span>
<span>  </span>
<span>  <span class="co"># Estimate these metrics:</span></span>
<span>  <span class="va">reg_metrics</span> <span class="op">&lt;-</span> <span class="fu">metric_set</span><span class="op">(</span><span class="va">rmse</span>, <span class="va">rsq</span><span class="op">)</span></span>
<span>  </span>
<span>  <span class="va">model</span> <span class="op">|&gt;</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/r/stats/predict.html">predict</a></span><span class="op">(</span><span class="va">dat</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>    <span class="fu">bind_cols</span><span class="op">(</span><span class="va">dat</span> <span class="op">|&gt;</span> <span class="fu">select</span><span class="op">(</span><span class="va">Sale_Price</span><span class="op">)</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>    <span class="fu">reg_metrics</span><span class="op">(</span><span class="va">Sale_Price</span>, <span class="va">.pred</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>    <span class="fu">select</span><span class="op">(</span><span class="op">-</span><span class="va">.estimator</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>    <span class="fu">mutate</span><span class="op">(</span>object <span class="op">=</span> <span class="va">obj_name</span>, data <span class="op">=</span> <span class="va">data_name</span><span class="op">)</span></span>
<span><span class="op">}</span></span></code><button title="Kopiuj do schowka" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Aby porównać modele zostaną obliczone miary RMSE i <span class="math inline">\(R^2\)</span> dla obu modeli na zbiorze uczącym.</p>
<div class="cell">
<details open="" class="code-fold"><summary>Kod</summary><div class="sourceCode" id="cb3"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu">estimate_perf</span><span class="op">(</span><span class="va">rf_fit</span>, <span class="va">ames_train</span><span class="op">)</span></span></code><button title="Kopiuj do schowka" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output cell-output-stdout">
<pre><code># A tibble: 2 × 4
  .metric .estimate object data 
  &lt;chr&gt;       &lt;dbl&gt; &lt;chr&gt;  &lt;chr&gt;
1 rmse       0.0363 rf_fit train
2 rsq        0.961  rf_fit train</code></pre>
</div>
<details open="" class="code-fold"><summary>Kod</summary><div class="sourceCode" id="cb5"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu">estimate_perf</span><span class="op">(</span><span class="va">lm_fit</span>, <span class="va">ames_train</span><span class="op">)</span></span></code><button title="Kopiuj do schowka" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output cell-output-stdout">
<pre><code># A tibble: 2 × 4
  .metric .estimate object data 
  &lt;chr&gt;       &lt;dbl&gt; &lt;chr&gt;  &lt;chr&gt;
1 rmse       0.0749 lm_fit train
2 rsq        0.822  lm_fit train</code></pre>
</div>
</div>
<p>Na podstawie powyższych wyników można by wyciągnąć wniosek, że model lasu losowego jest znacznie lepszy, ponieważ obie miary wyraźnie lepsze są w tym przypadku. W taką pułapkę łapie się większość osób stawiających pierwsze kroki w ML. Ale już porównując te modele na próbie testowej widzimy, że różnice pomiędzy modelami się zacierają.</p>

<div class="no-row-height column-margin column-container"><div class="">
<p><a href="images/chap_46.png" class="lightbox" data-gallery="quarto-lightbox-gallery-1"><img src="images/chap_46.png" class="img-fluid" width="400"></a></p>
</div></div><div class="cell">
<details open="" class="code-fold"><summary>Kod</summary><div class="sourceCode" id="cb7"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu">estimate_perf</span><span class="op">(</span><span class="va">rf_fit</span>, <span class="va">ames_test</span><span class="op">)</span></span></code><button title="Kopiuj do schowka" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output cell-output-stdout">
<pre><code># A tibble: 2 × 4
  .metric .estimate object data 
  &lt;chr&gt;       &lt;dbl&gt; &lt;chr&gt;  &lt;chr&gt;
1 rmse       0.0702 rf_fit test 
2 rsq        0.838  rf_fit test </code></pre>
</div>
<details open="" class="code-fold"><summary>Kod</summary><div class="sourceCode" id="cb9"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu">estimate_perf</span><span class="op">(</span><span class="va">lm_fit</span>, <span class="va">ames_test</span><span class="op">)</span></span></code><button title="Kopiuj do schowka" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output cell-output-stdout">
<pre><code># A tibble: 2 × 4
  .metric .estimate object data 
  &lt;chr&gt;       &lt;dbl&gt; &lt;chr&gt;  &lt;chr&gt;
1 rmse       0.0760 lm_fit test 
2 rsq        0.808  lm_fit test </code></pre>
</div>
</div>
<p>Skąd takie różnice?</p>
<p>Wiele modeli predykcyjnych jest w stanie uczyć się złożonych zależności. W statystyce są one powszechnie określane jako <em>low bias models</em>. Wiele modeli uczenia maszynowego typu <em>black-box</em> ma niski poziom błędu systematycznego, co oznacza, że mogą one odtwarzać złożone relacje. Inne modele (takie jak regresja liniowa/logistyczna, analiza dyskryminacyjna i inne) nie są tak elastyczne i są uważane za modele o wysokim współczynniku błędu (ang. <em>high bias models</em>).</p>
<p>W przypadku modelu o niskim obciążeniu, wysoki stopień zdolności predykcyjnej może czasami spowodować, że model prawie zapamiętuje dane ze zbioru treningowego. Jako oczywisty przykład, można rozważyć model 1-najbliższego sąsiada. Zawsze będzie zapewniał doskonałe przewidywania dla zestawu treningowego, niezależnie od tego, jak dobrze naprawdę działa dla innych zestawów danych. Modele losowego lasu są podobne; predykcja na zbiorze uczącym zawsze spowoduje nieprawdziwie optymistyczne oszacowanie wydajności.</p>
<p>Brak znaczących różnic w dopasowaniu modelu regresji na obu zbiorach wynika z małej złożoności modelu, a co za tym idzie niskiej wariancji modelu.</p>
</div>

<div class="no-row-height column-margin column-container"><div class="">
<div class="quarto-figure quarto-figure-center">
<figure class="figure"><p><a href="images/chap_38.png" class="lightbox" data-gallery="quarto-lightbox-gallery-2"><img src="images/chap_38.png" class="img-fluid quarto-figure quarto-figure-center figure-img" width="400"></a></p>
</figure>
</div>
</div></div><p>Powyższy przykład pokazuje, że ocena modeli na zbiorze uczącym nie jest właściwym podejściem, ponieważ może zwrócić zbyt optymistyczny poziom dopasowania. A skoro zbiór testowy nie powinien być używany natychmiast, a predykcja na zbiorze treningowym jest złym pomysłem, to co należy zrobić? Rozwiązaniem są metody ponownego próbkowania (ang. <em>resampling</em>), takie jak walidacja krzyżowa lub zestawy walidacyjne.</p>
<p>Metody resamplingu są empirycznymi systemami symulacji, które emulują proces używania pewnych danych do modelowania i innych danych do oceny. Większość metod resamplingu jest iteracyjna, co oznacza, że proces ten jest powtarzany wielokrotnie. Schemat na <a href="#fig-resamp1" class="quarto-xref">Rys.&nbsp;<span>7.1</span></a> ilustruje, jak generalnie działają metody resamplingu.</p>
<div id="fig-resamp1" class="quarto-figure quarto-figure-center quarto-float anchored" data-fig-align="center">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-resamp1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="images/Zrzut ekranu 2023-02-20 o 19.54.34.png" class="lightbox" data-glightbox="description: .lightbox-desc-3" data-gallery="quarto-lightbox-gallery-3"><img src="images/Zrzut ekranu 2023-02-20 o 19.54.34.png" class="img-fluid quarto-figure quarto-figure-center figure-img" width="500"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-resamp1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Rys.&nbsp;7.1: Przykład podziału zbioru danych z wykorzystaniem resamplingu
</figcaption></figure>
</div>
<p><em>Resampling</em> jest przeprowadzany tylko na zbiorze treningowym. Zbiór testowy nie bierze w nim udziału. Dla każdej iteracji ponownego próbkowania dane są dzielone na dwie podpróbki, na których:</p>
<ul>
<li>Model jest dopasowywany za pomocą zbioru analitycznego (ang. <em>analysis set</em>).</li>
<li>Model jest oceniany za pomocą zbioru do oceny (ang. <em>assessment set</em>).</li>
</ul>
<p>Te dwie próby danych są w pewnym sensie analogiczne do zestawów treningowych i testowych. Używany przez nas język analizy i oceny pozwala uniknąć pomyłek związanych z początkowym podziałem danych. Te zbiory danych wzajemnie się wykluczają. Schemat podziału stosowany do tworzenia zbiorów analizy i oceny jest zazwyczaj cechą definiującą metodę.</p>
<p>Załóżmy, że przeprowadzono 20 iteracji ponownego próbkowania. Oznacza to, że 20 oddzielnych modeli jest dopasowywanych do zbiorów analiz, a odpowiadające im zbiory oceny dają 20 zbiorów statystyk wydajności. Ostateczne oszacowanie wydajności dla modelu jest średnią z 20 powtórzeń statystyki. Średnia ta ma bardzo dobre właściwości uogólniające i jest znacznie lepsza niż szacunki na zbiorze uczącym.</p>

<div class="no-row-height column-margin column-container"><div class="">
<div class="quarto-figure quarto-figure-center">
<figure class="figure"><p><a href="https://i.pinimg.com/564x/5d/40/fe/5d40febb383da04ada236afede0ab996.jpg" class="lightbox" data-gallery="quarto-lightbox-gallery-4"><img src="https://i.pinimg.com/564x/5d/40/fe/5d40febb383da04ada236afede0ab996.jpg" class="img-fluid quarto-figure quarto-figure-center figure-img" width="400"></a></p>
</figure>
</div>
</div></div><section id="walidacja-krzyżowa" class="level2 page-columns page-full" data-number="7.1"><h2 data-number="7.1" class="anchored" data-anchor-id="walidacja-krzyżowa">
<span class="header-section-number">7.1</span> Walidacja krzyżowa</h2>
<p>Walidacja krzyżowa (ang. <em>cross-validation</em>) jest dobrze ugruntowaną metodą próbkowania. Chociaż istnieje wiele odmian, najbardziej powszechną metodą walidacji krzyżowej jest <span class="math inline">\(V\)</span>-krotna walidacja krzyżowa. Dane są losowo dzielone na <span class="math inline">\(V\)</span> zbiorów o mniej więcej równej wielkości (zwanych krotkami lub foldami). Dla ilustracji, <span class="math inline">\(V = 3\)</span> jest pokazane na <a href="#fig-cross1" class="quarto-xref">Rys.&nbsp;<span>7.2</span></a> dla zbioru danych składającego się z 30 punktów zbioru treningowego z losowym przydziałem foldów. Liczba wewnątrz symboli to numer próbki.</p>
<div id="fig-cross1" class="quarto-figure quarto-figure-center quarto-float anchored" data-fig-align="center">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-cross1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="images/Zrzut ekranu 2023-02-20 o 20.01.18.png" class="lightbox" data-glightbox="description: .lightbox-desc-5" data-gallery="quarto-lightbox-gallery-5"><img src="images/Zrzut ekranu 2023-02-20 o 20.01.18.png" class="img-fluid quarto-figure quarto-figure-center figure-img" width="400"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-cross1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Rys.&nbsp;7.2: 3-krotny sprawdzian krzyżowy
</figcaption></figure>
</div>
<p>Kolory symboli na <a href="#fig-cross1" class="quarto-xref">Rys.&nbsp;<span>7.2</span></a> reprezentują ich losowo przypisane foldy.</p>
<p>W przypadku trzykrotnej walidacji krzyżowej trzy iteracje próbkowania przedstawiono na <a href="#fig-cross2" class="quarto-xref">Rys.&nbsp;<span>7.3</span></a>. Dla każdej iteracji jeden fold jest zatrzymywany do oceny modelu, a pozostałe foldy są używane do uczenia modelu. Proces ten jest kontynuowany dla każdego folda, tak że trzy modele dają trzy zestawy statystyk dopasowania.</p>
<div id="fig-cross2" class="quarto-figure quarto-figure-center quarto-float anchored" data-fig-align="center">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-cross2-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="images/Zrzut ekranu 2023-02-20 o 20.01.30.png" class="lightbox" data-glightbox="description: .lightbox-desc-6" data-gallery="quarto-lightbox-gallery-6"><img src="images/Zrzut ekranu 2023-02-20 o 20.01.30.png" class="img-fluid quarto-figure quarto-figure-center figure-img" width="500"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-cross2-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Rys.&nbsp;7.3: Zastosowanie foldów w uczeniu i ocenie dopasowania modeli
</figcaption></figure>
</div>
<p>Gdy <span class="math inline">\(V = 3\)</span>, zbiory analiz stanowią 2/3 zbioru treningowego, a każdy zbiór oceny stanowi odrębną 1/3. Końcowa estymacja resamplingu wydajności uśrednia każdą z <span class="math inline">\(V\)</span> replik.</p>

<div class="no-row-height column-margin column-container"><div class="">
<div class="quarto-figure quarto-figure-center">
<figure class="figure"><p><a href="images/chap_11.png" class="lightbox" data-gallery="quarto-lightbox-gallery-7"><img src="images/chap_11.png" class="img-fluid quarto-figure quarto-figure-center figure-img" width="400"></a></p>
</figure>
</div>
</div></div><p>Użycie <span class="math inline">\(V = 3\)</span> jest dobrym wyborem do zilustrowania walidacji krzyżowej, ale jest to zły wybór w praktyce, ponieważ jest zbyt mało foldów, aby wygenerować wiarygodne szacunki. W praktyce wartości <span class="math inline">\(V\)</span> to najczęściej 5 lub 10; raczej preferujemy 10-krotną walidację krzyżową jako domyślną, ponieważ jest ona wystarczająco duża, aby uzyskać dobre wyniki w większości sytuacji.</p>
<p>Jakie są skutki zmiany <span class="math inline">\(V\)</span>? Większe wartości powodują, że szacunki z próbkowania mają mały błąd/obciążenie, ale znaczną wariancję. Mniejsze wartości <span class="math inline">\(V\)</span> mają duży błąd, ale niską wariancję. Preferujemy 10-krotne, ponieważ szum jest zmniejszony przez replikacje, ale obciążenie już nie.</p>
<div class="cell">
<details open="" class="code-fold"><summary>Kod</summary><div class="sourceCode" id="cb11"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/Random.html">set.seed</a></span><span class="op">(</span><span class="fl">1001</span><span class="op">)</span></span>
<span><span class="va">ames_folds</span> <span class="op">&lt;-</span> <span class="fu">vfold_cv</span><span class="op">(</span><span class="va">ames_train</span>, v <span class="op">=</span> <span class="fl">10</span><span class="op">)</span></span>
<span><span class="va">ames_folds</span></span></code><button title="Kopiuj do schowka" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output cell-output-stdout">
<pre><code>#  10-fold cross-validation 
# A tibble: 10 × 2
   splits             id    
   &lt;list&gt;             &lt;chr&gt; 
 1 &lt;split [2107/235]&gt; Fold01
 2 &lt;split [2107/235]&gt; Fold02
 3 &lt;split [2108/234]&gt; Fold03
 4 &lt;split [2108/234]&gt; Fold04
 5 &lt;split [2108/234]&gt; Fold05
 6 &lt;split [2108/234]&gt; Fold06
 7 &lt;split [2108/234]&gt; Fold07
 8 &lt;split [2108/234]&gt; Fold08
 9 &lt;split [2108/234]&gt; Fold09
10 &lt;split [2108/234]&gt; Fold10</code></pre>
</div>
<details open="" class="code-fold"><summary>Kod</summary><div class="sourceCode" id="cb13"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu">lobstr</span><span class="fu">::</span><span class="fu"><a href="https://lobstr.r-lib.org/reference/obj_size.html">obj_size</a></span><span class="op">(</span><span class="va">ames_folds</span><span class="op">)</span></span></code><button title="Kopiuj do schowka" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output cell-output-stdout">
<pre><code>944.36 kB</code></pre>
</div>
<details open="" class="code-fold"><summary>Kod</summary><div class="sourceCode" id="cb15"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu">lobstr</span><span class="fu">::</span><span class="fu"><a href="https://lobstr.r-lib.org/reference/obj_size.html">obj_size</a></span><span class="op">(</span><span class="va">ames_train</span><span class="op">)</span></span></code><button title="Kopiuj do schowka" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output cell-output-stdout">
<pre><code>849.83 kB</code></pre>
</div>
</div>
<p>Kolumna o nazwie <em>splits</em> zawiera informacje o tym, jak podzielone zostaną dane (podobnie jak obiekt używany do tworzenia początkowej partycji trening/test). Chociaż każdy podział ma zagnieżdżoną kopię całego zbioru treningowego, R jest na tyle inteligentny, że nie tworzy kopii danych w pamięci. Metoda <code>print</code> wewnątrz <code>tibble</code> pokazuje częstość występowania każdego z nich: [2107/235] wskazuje, że około dwóch tysięcy próbek znajduje się w zbiorze analitycznym, a 235 w tym konkretnym zbiorze oceniającym.</p>
</section><section id="sprawdzian-krzyżowy-z-powtórzeniami" class="level2 page-columns page-full" data-number="7.2"><h2 data-number="7.2" class="anchored" data-anchor-id="sprawdzian-krzyżowy-z-powtórzeniami">
<span class="header-section-number">7.2</span> Sprawdzian krzyżowy z powtórzeniami</h2>
<p>Najważniejszą odmianą walidacji krzyżowej jest <span class="math inline">\(V\)</span>-krotna walidacja krzyżowa z powtórzeniami. W zależności od rozmiaru danych i innych cech, ocena modelu uzyskana w wyniku <span class="math inline">\(V\)</span>-krotnej walidacji krzyżowej może być nadmiernie zaszumiona. Podobnie jak w przypadku wielu problemów statystycznych, jednym ze sposobów zmniejszenia szumu jest zebranie większej ilości danych. W przypadku walidacji krzyżowej oznacza to uśrednienie więcej niż <span class="math inline">\(V\)</span> statystyk.</p>

<div class="no-row-height column-margin column-container"><div class="">
<div class="quarto-figure quarto-figure-center">
<figure class="figure"><p><a href="images/chap_20.png" class="lightbox" data-gallery="quarto-lightbox-gallery-8"><img src="images/chap_20.png" class="img-fluid quarto-figure quarto-figure-center figure-img" width="400"></a></p>
</figure>
</div>
</div></div><p>Aby stworzyć <span class="math inline">\(R\)</span> powtórzeń <span class="math inline">\(V\)</span>-krotnej walidacji krzyżowej, ten sam proces generowania foldów jest wykonywany <span class="math inline">\(R\)</span> razy, aby wygenerować <span class="math inline">\(R\)</span> zbiorów złożonych z <span class="math inline">\(V\)</span> podzbiorów. Zamiast uśredniania <span class="math inline">\(V\)</span> statystyk, <span class="math inline">\(V\times R\)</span> wartości daje ostateczną estymację resamplingu.</p>
<p>Rozważmy dane <code>ames</code>. Średnio, 10-krotna walidacja krzyżowa używa zestawów oceny, które zawierają około 234 obserwacji. Jeśli RMSE jest wybraną statystyką, możemy oznaczyć odchylenie standardowe tego oszacowania jako <span class="math inline">\(\sigma\)</span>. Przy 10-krotnej walidacji krzyżowej błąd standardowy średniej RMSE wynosi <span class="math inline">\(\sigma/\sqrt{10}\)</span>. Podczas gdy ta wielkość może charakteryzować się jeszcze dużym szumem, powtórzenia zmniejszają błąd standardowy do <span class="math inline">\(\sigma/\sqrt{10R}\)</span>. Dla 10-krotnej walidacji krzyżowej z <span class="math inline">\(R\)</span> powtórzeniami, wykres na <a href="#fig-cross3" class="quarto-xref">Rys.&nbsp;<span>7.4</span></a> pokazuje, jak szybko błąd standardowy maleje wraz z liczbą powtórzeń.</p>
<div id="fig-cross3" class="quarto-figure quarto-figure-center quarto-float anchored" data-fig-align="center">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-cross3-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="images/Zrzut ekranu 2023-02-20 o 21.09.46.png" class="lightbox" data-glightbox="description: .lightbox-desc-9" data-gallery="quarto-lightbox-gallery-9"><img src="images/Zrzut ekranu 2023-02-20 o 21.09.46.png" class="img-fluid quarto-figure quarto-figure-center figure-img" width="600"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-cross3-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Rys.&nbsp;7.4: Wielkość błędu standardowego estymacji w zależności od liczby powtórzeń walidacji krzyżowych
</figcaption></figure>
</div>
<p>Generalnie zwiększanie liczby replikacji nie ma dużego wpływu na błąd standardowy estymacji, chyba że bazowa wartość <span class="math inline">\(\sigma\)</span> jest duża, wówczas faktycznie warto zwiększać liczbę replikacji.</p>
<div class="cell">
<details open="" class="code-fold"><summary>Kod</summary><div class="sourceCode" id="cb17"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu">vfold_cv</span><span class="op">(</span><span class="va">ames_train</span>, v <span class="op">=</span> <span class="fl">10</span>, repeats <span class="op">=</span> <span class="fl">5</span><span class="op">)</span></span></code><button title="Kopiuj do schowka" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output cell-output-stdout">
<pre><code>#  10-fold cross-validation repeated 5 times 
# A tibble: 50 × 3
   splits             id      id2   
   &lt;list&gt;             &lt;chr&gt;   &lt;chr&gt; 
 1 &lt;split [2107/235]&gt; Repeat1 Fold01
 2 &lt;split [2107/235]&gt; Repeat1 Fold02
 3 &lt;split [2108/234]&gt; Repeat1 Fold03
 4 &lt;split [2108/234]&gt; Repeat1 Fold04
 5 &lt;split [2108/234]&gt; Repeat1 Fold05
 6 &lt;split [2108/234]&gt; Repeat1 Fold06
 7 &lt;split [2108/234]&gt; Repeat1 Fold07
 8 &lt;split [2108/234]&gt; Repeat1 Fold08
 9 &lt;split [2108/234]&gt; Repeat1 Fold09
10 &lt;split [2108/234]&gt; Repeat1 Fold10
# ℹ 40 more rows</code></pre>
</div>
</div>
</section><section id="leave-one-out" class="level2 page-columns page-full" data-number="7.3"><h2 data-number="7.3" class="anchored" data-anchor-id="leave-one-out">
<span class="header-section-number">7.3</span> Leave-One-Out</h2>
<p>Jedną z odmian walidacji krzyżowej jest walidacja krzyżowa typu <em>Leave-One-Out</em> (LOO). Jeśli mamy <span class="math inline">\(n\)</span> próbek zbioru treningowego, <span class="math inline">\(n\)</span> modeli jest dopasowywanych przy użyciu <span class="math inline">\(n - 1\)</span> wierszy zbioru treningowego. Każdy model przewiduje pojedynczy wykluczony punkt danych. Na koniec próbkowania <span class="math inline">\(n\)</span> prognoz jest łączonych w celu uzyskania pojedynczej statystyki dopasowania</p>

<div class="no-row-height column-margin column-container"><div class="">
<div class="quarto-figure quarto-figure-center">
<figure class="figure"><p><a href="images/chap_41.png" class="lightbox" data-gallery="quarto-lightbox-gallery-10"><img src="images/chap_41.png" class="img-fluid quarto-figure quarto-figure-center figure-img" width="400"></a></p>
</figure>
</div>
</div></div><p>Metody LOO są gorsza w porównaniu z prawie każdą inną metodą oceny dopasowania. Dla wszystkich oprócz patologicznie małych próbek, LOO jest obliczeniowo złożony i może nie mieć dobrych właściwości statystycznych. Chociaż pakiet <code>rsample</code> zawiera funkcję <code>loo_cv()</code>, obiekty te nie są mocno zintegrowane z pakietami <code>tidymodels</code>.</p>
</section><section id="walidacja-metodą-monte-carlo" class="level2" data-number="7.4"><h2 data-number="7.4" class="anchored" data-anchor-id="walidacja-metodą-monte-carlo">
<span class="header-section-number">7.4</span> Walidacja metodą Monte-Carlo</h2>
<p>Innym wariantem <span class="math inline">\(V\)</span>-krotnej walidacji krzyżowej jest walidacja krzyżowa Monte-Carlo (ang. <em>Monte-Carlo Cross-Validation</em> - MCCV) <span class="citation" data-cites="xu2001">(<a href="references.html#ref-xu2001" role="doc-biblioref">Xu i Liang 2001</a>)</span>. Podobnie jak w sprawdzianie krzyżowym, przydziela ona ustaloną część danych do zbiorów oceny. Różnica między MCCV a zwykłą walidacją krzyżową polega na tym, że w przypadku MCCV ta część danych jest za każdym razem wybierana losowo. Przez to powstają zestawy oceny, które nie wykluczają się wzajemnie.</p>
<div class="cell">
<details open="" class="code-fold"><summary>Kod</summary><div class="sourceCode" id="cb19"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu">mc_cv</span><span class="op">(</span><span class="va">ames_train</span>, prop <span class="op">=</span> <span class="fl">9</span><span class="op">/</span><span class="fl">10</span>, times <span class="op">=</span> <span class="fl">20</span><span class="op">)</span></span></code><button title="Kopiuj do schowka" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output cell-output-stdout">
<pre><code># Monte Carlo cross-validation (0.9/0.1) with 20 resamples  
# A tibble: 20 × 2
   splits             id        
   &lt;list&gt;             &lt;chr&gt;     
 1 &lt;split [2107/235]&gt; Resample01
 2 &lt;split [2107/235]&gt; Resample02
 3 &lt;split [2107/235]&gt; Resample03
 4 &lt;split [2107/235]&gt; Resample04
 5 &lt;split [2107/235]&gt; Resample05
 6 &lt;split [2107/235]&gt; Resample06
 7 &lt;split [2107/235]&gt; Resample07
 8 &lt;split [2107/235]&gt; Resample08
 9 &lt;split [2107/235]&gt; Resample09
10 &lt;split [2107/235]&gt; Resample10
11 &lt;split [2107/235]&gt; Resample11
12 &lt;split [2107/235]&gt; Resample12
13 &lt;split [2107/235]&gt; Resample13
14 &lt;split [2107/235]&gt; Resample14
15 &lt;split [2107/235]&gt; Resample15
16 &lt;split [2107/235]&gt; Resample16
17 &lt;split [2107/235]&gt; Resample17
18 &lt;split [2107/235]&gt; Resample18
19 &lt;split [2107/235]&gt; Resample19
20 &lt;split [2107/235]&gt; Resample20</code></pre>
</div>
</div>
</section><section id="zbiór-walidacyjny" class="level2" data-number="7.5"><h2 data-number="7.5" class="anchored" data-anchor-id="zbiór-walidacyjny">
<span class="header-section-number">7.5</span> Zbiór walidacyjny</h2>
<p>We wcześniejszych rozdziałach wspominana była metoda z wykorzystaniem zbioru walidacyjnego. Polega ona na tym, że przy tworzeniu podziału zbioru na uczący i testowy, dodatkowo zbiór uczący dzieli się na właściwy uczący i walidacyjny (patrz <a href="#fig-val1" class="quarto-xref">Rys.&nbsp;<span>7.5</span></a>). Zbiór walidacyjny jest wykorzystywany do oceny dopasowania modelu, np. w procesie optymalizacji hiperparametrów modelu.</p>
<div id="fig-val1" class="quarto-figure quarto-figure-center quarto-float anchored" data-fig-align="center">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-val1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="images/Zrzut ekranu 2023-02-20 o 21.32.37.png" class="lightbox" data-glightbox="description: .lightbox-desc-11" data-gallery="quarto-lightbox-gallery-11"><img src="images/Zrzut ekranu 2023-02-20 o 21.32.37.png" class="img-fluid quarto-figure quarto-figure-center figure-img" width="400"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-val1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Rys.&nbsp;7.5: Podział zbiorów na uczący, testowy i walidacyjny
</figcaption></figure>
</div>
<p>Podziału można dokonać też od razu dzieląc cały zbiór danych na trzy części (patrz <a href="#fig-val2" class="quarto-xref">Rys.&nbsp;<span>7.6</span></a>).</p>
<div id="fig-val2" class="quarto-figure quarto-figure-center quarto-float anchored" data-fig-align="center">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-val2-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="images/Zrzut ekranu 2023-02-20 o 21.32.11.png" class="lightbox" data-glightbox="description: .lightbox-desc-12" data-gallery="quarto-lightbox-gallery-12"><img src="images/Zrzut ekranu 2023-02-20 o 21.32.11.png" class="img-fluid quarto-figure quarto-figure-center figure-img" width="400"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-val2-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Rys.&nbsp;7.6: Podział na trzy zbiory
</figcaption></figure>
</div>
<p>Zbiory walidacyjne są często wykorzystywane, gdy pierwotna pula danych jest bardzo duża. W tym przypadku, pojedyncza duża partia danych jest wystarczająca do scharakteryzowania dopasowania modelu bez konieczności wykonywania wielu iteracji próbkowania.</p>
<div class="cell">
<details open="" class="code-fold"><summary>Kod</summary><div class="sourceCode" id="cb21"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/Random.html">set.seed</a></span><span class="op">(</span><span class="fl">1002</span><span class="op">)</span></span>
<span><span class="va">val_set</span> <span class="op">&lt;-</span> <span class="fu">validation_split</span><span class="op">(</span><span class="va">ames_train</span>, prop <span class="op">=</span> <span class="fl">3</span><span class="op">/</span><span class="fl">4</span><span class="op">)</span></span>
<span><span class="va">val_set</span></span></code><button title="Kopiuj do schowka" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output cell-output-stdout">
<pre><code># Validation Set Split (0.75/0.25)  
# A tibble: 1 × 2
  splits             id        
  &lt;list&gt;             &lt;chr&gt;     
1 &lt;split [1756/586]&gt; validation</code></pre>
</div>
</div>
</section><section id="bootstrapping" class="level2" data-number="7.6"><h2 data-number="7.6" class="anchored" data-anchor-id="bootstrapping">
<span class="header-section-number">7.6</span> Bootstrapping</h2>
<p><em>Bootstrap</em> został pierwotnie wynaleziony jako metoda aproksymacji próbkowego rozkładu statystyki, którego własności teoretyczne są nieznane <span class="citation" data-cites="davison1997">(<a href="references.html#ref-davison1997" role="doc-biblioref">Davison i Hinkley 1997</a>)</span>. Wykorzystanie jej do szacowania dopasowania modelu jest wtórnym zastosowaniem tej metody.</p>
<p>Próbka bootstrapowa zbioru treningowego to próbka, która ma ten sam rozmiar co zbiór treningowy, ale jest losowana ze zwracaniem. Oznacza to, że niektóre obserwacje zbioru treningowego są wielokrotnie wybierane do zbioru analitycznego. Każdy punkt danych ma 63,2% szans na włączenie do zbioru uczącego przynajmniej raz. Zestaw oceny zawiera wszystkie próbki zestawu treningowego, które nie zostały wybrane do zestawu analitycznego (średnio 36,8% zestawu treningowego). Podczas <em>bootstrappingu</em> zestaw oceny jest często nazywany próbką poza workiem (ang. <em>Out-Of-Bag)</em>.</p>
<p>Dla zbioru treningowego składającego się z 30 próbek, schemat trzech próbek bootstrapowych przedstawiono na <a href="#fig-boot1" class="quarto-xref">Rys.&nbsp;<span>7.7</span></a></p>
<div id="fig-boot1" class="quarto-figure quarto-figure-center quarto-float anchored" data-fig-align="center">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-boot1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="images/Zrzut ekranu 2023-02-20 o 21.45.08.png" class="lightbox" data-glightbox="description: .lightbox-desc-13" data-gallery="quarto-lightbox-gallery-13"><img src="images/Zrzut ekranu 2023-02-20 o 21.45.08.png" class="img-fluid quarto-figure quarto-figure-center figure-img" width="500"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-boot1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Rys.&nbsp;7.7: Trzy próby bootstrapowe
</figcaption></figure>
</div>
<div class="cell">
<details open="" class="code-fold"><summary>Kod</summary><div class="sourceCode" id="cb23"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu">bootstraps</span><span class="op">(</span><span class="va">ames_train</span>, times <span class="op">=</span> <span class="fl">5</span><span class="op">)</span></span></code><button title="Kopiuj do schowka" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output cell-output-stdout">
<pre><code># Bootstrap sampling 
# A tibble: 5 × 2
  splits             id        
  &lt;list&gt;             &lt;chr&gt;     
1 &lt;split [2342/858]&gt; Bootstrap1
2 &lt;split [2342/855]&gt; Bootstrap2
3 &lt;split [2342/852]&gt; Bootstrap3
4 &lt;split [2342/851]&gt; Bootstrap4
5 &lt;split [2342/867]&gt; Bootstrap5</code></pre>
</div>
</div>
<p>Próbki bootstrapowe dają oszacowania dopasowania, które mają bardzo niską wariancję (w przeciwieństwie do walidacji krzyżowej), ale są pesymistyczne w ocenie obciążenia. Oznacza to, że jeśli prawdziwa dokładność modelu wynosi 90%, bootstrap będzie miał tendencję do oszacowania wartości mniejszej niż 90%. Wielkość błędu systematycznego nie może być określona empirycznie z wystarczającą dokładnością. Dodatkowo, wielkość błędu systematycznego zmienia się w zależności od skali dopasowania. Na przykład obciążenie będzie prawdopodobnie inne, gdy dokładność wynosi 90% w porównaniu z 70%.</p>
<p><em>Bootstrap</em> jest również wykorzystywany wewnątrz wielu modeli. Na przykład, wspomniany wcześniej model lasu losowego zawierał 1000 indywidualnych drzew decyzyjnych. Każde drzewo było produktem innej próbki bootstrapowej zbioru treningowego.</p>
</section><section id="kroczące-próbkowanie-źródła" class="level2" data-number="7.7"><h2 data-number="7.7" class="anchored" data-anchor-id="kroczące-próbkowanie-źródła">
<span class="header-section-number">7.7</span> Kroczące próbkowanie źródła</h2>
<p>Gdy dane mają istotny składnik czasowy (jak np. szeregi czasowe), metoda próbkowania powinna pozwolić na oszacowanie sezonowych i okresowych trendów w szeregach czasowych. Technika, która losowo próbkuje wartości ze zbioru treningowego, nie pozwoli na oszacowanie tych wzorców.</p>
<p>Kroczące próbkowanie źródła (ang. <em>rolling forecast origin resampling</em>) jest metodą, która emuluje sposób, w jaki dane szeregów czasowych są często partycjonowane w praktyce, estymując parametry modelu na danymych historycznych i oceniając go z najnowszymi danymi <span class="citation" data-cites="hyndman">(<a href="references.html#ref-hyndman" role="doc-biblioref">Hyndman i Athanasopoulos 2018</a>)</span>. Dla tego typu resamplingu określa się rozmiar zbiorów analiz i ocen. Pierwsza iteracja resamplingu wykorzystuje te rozmiary, zaczynając od początku serii. Druga iteracja wykorzystuje te same rozmiary danych, ale przesuwa się o ustaloną liczbę próbek.</p>
<div id="fig-rolling" class="quarto-figure quarto-figure-center quarto-float anchored" data-fig-align="center">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-rolling-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="images/Zrzut ekranu 2023-02-20 o 21.45.23.png" class="lightbox" data-glightbox="description: .lightbox-desc-14" data-gallery="quarto-lightbox-gallery-14"><img src="images/Zrzut ekranu 2023-02-20 o 21.45.23.png" class="img-fluid quarto-figure quarto-figure-center figure-img" width="500"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-rolling-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Rys.&nbsp;7.8: Próbkowanie kroczące ze źródła
</figcaption></figure>
</div>
<p>Dla zilustrowania, zbiór treningowy składający się z piętnastu próbek został ponownie próbkowany z rozmiarem zbioru analizy wynoszącym osiem próbek i zbioru oceny wynoszącym trzy. W drugiej iteracji odrzucono pierwszą próbkę zbioru uczącego, a oba zbiory danych przesunięto do przodu o jeden. W tej konfiguracji uzyskuje się pięć próbek, jak pokazano na <a href="#fig-rolling" class="quarto-xref">Rys.&nbsp;<span>7.8</span></a>.</p>
<p>Istnieją dwie różne konfiguracje tej metody:</p>
<ul>
<li>Zestaw analiz może narastać (w przeciwieństwie do utrzymywania tego samego rozmiaru). Po pierwszym początkowym zestawie analitycznym nowe próbki mogą narastać bez odrzucania wcześniejszych danych. W rezultacie oznacza to, że po nauczeniu i ocenie dopasowania modelu na <em>Resample 1,</em> model jest uczony na zbiorze rozszerzonym o obserwację 9, czyli na danych od 1 do 9. Następnie oceniany na obserwacjach od 10 do 12, itd.</li>
<li>Próbki nie muszą być zwiększane o jeden. Na przykład, w przypadku dużych zestawów danych, blok przyrostowy może wynosić tydzień lub miesiąc zamiast dnia.</li>
</ul></section><section id="oszacowanie-dopasowania-z-wykorzystaniem-resamplingu" class="level2 page-columns page-full" data-number="7.8"><h2 data-number="7.8" class="anchored" data-anchor-id="oszacowanie-dopasowania-z-wykorzystaniem-resamplingu">
<span class="header-section-number">7.8</span> Oszacowanie dopasowania z wykorzystaniem resamplingu</h2>
<p>Każda z metod <em>resamplingu</em> omówionych w tym rozdziale może być wykorzystana do oceny procesu modelowania (w tym przetwarzania wstępnego, dopasowania modelu itp.). Metody te są skuteczne, ponieważ do trenowania modelu i oceny modelu wykorzystywane są różne grupy danych. Przebiega on w następujący sposób:</p>
<ol type="1">
<li>Podczas <em>resamplingu</em> zbiór analityczny jest używany do wstępnego przetwarzania danych, a następnie przetworzonych danych używa do dopasowania modelu.</li>
<li>Statystyki przetwarzania wstępnego opracowane przez zbiór analiz są stosowane do zbioru oceny. Prognozy ze zbioru oceny wskazują wydajność modelu na nowych danych.</li>
</ol>
<p>Ta sekwencja powtarza się dla każdej próby. Jeśli istnieje <span class="math inline">\(B\)</span> prób, wówczas mamy <span class="math inline">\(B\)</span> powtórzeń każdej z metryk dopasowania. Ostateczna ocena jest średnią tych <span class="math inline">\(B\)</span> statystyk. Jeśli <span class="math inline">\(B = 1\)</span>, jak w przypadku zbioru walidacyjnego, pojedyncze statystyki reprezentują ogólne dopasowanie.</p>

<div class="no-row-height column-margin column-container"><div class="">
<p><a href="https://media4.giphy.com/media/IfFN6NwhaUl3CI4mgG/giphy.gif?cid=ecf05e479vdinrjf0nel53vw654p1yc1bgr3ey8fkbw1o74t&amp;rid=giphy.gif&amp;ct=g" class="lightbox" data-gallery="quarto-lightbox-gallery-15"><img src="https://media4.giphy.com/media/IfFN6NwhaUl3CI4mgG/giphy.gif?cid=ecf05e479vdinrjf0nel53vw654p1yc1bgr3ey8fkbw1o74t&amp;rid=giphy.gif&amp;ct=g" class="img-fluid"></a></p>
</div></div><div class="cell">
<details open="" class="code-fold"><summary>Kod</summary><div class="sourceCode" id="cb25"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="co"># ustawiamy kontrolę resamplingu w ten sposbów aby zapisać predykcje i </span></span>
<span><span class="co"># nauczony przepływ - domyślnie nie są zapisywane</span></span>
<span><span class="va">keep_pred</span> <span class="op">&lt;-</span> <span class="fu">control_resamples</span><span class="op">(</span>save_pred <span class="op">=</span> <span class="cn">TRUE</span>, save_workflow <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/Random.html">set.seed</a></span><span class="op">(</span><span class="fl">1003</span><span class="op">)</span></span>
<span><span class="va">rf_res</span> <span class="op">&lt;-</span> </span>
<span>  <span class="va">rf_wflow</span> <span class="op">|&gt;</span></span>
<span>  <span class="fu">fit_resamples</span><span class="op">(</span>resamples <span class="op">=</span> <span class="va">ames_folds</span>, control <span class="op">=</span> <span class="va">keep_pred</span><span class="op">)</span></span>
<span><span class="va">rf_res</span></span></code><button title="Kopiuj do schowka" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output cell-output-stdout">
<pre><code># Resampling results
# 10-fold cross-validation 
# A tibble: 10 × 5
   splits             id     .metrics         .notes           .predictions
   &lt;list&gt;             &lt;chr&gt;  &lt;list&gt;           &lt;list&gt;           &lt;list&gt;      
 1 &lt;split [2107/235]&gt; Fold01 &lt;tibble [2 × 4]&gt; &lt;tibble [0 × 3]&gt; &lt;tibble&gt;    
 2 &lt;split [2107/235]&gt; Fold02 &lt;tibble [2 × 4]&gt; &lt;tibble [0 × 3]&gt; &lt;tibble&gt;    
 3 &lt;split [2108/234]&gt; Fold03 &lt;tibble [2 × 4]&gt; &lt;tibble [0 × 3]&gt; &lt;tibble&gt;    
 4 &lt;split [2108/234]&gt; Fold04 &lt;tibble [2 × 4]&gt; &lt;tibble [0 × 3]&gt; &lt;tibble&gt;    
 5 &lt;split [2108/234]&gt; Fold05 &lt;tibble [2 × 4]&gt; &lt;tibble [0 × 3]&gt; &lt;tibble&gt;    
 6 &lt;split [2108/234]&gt; Fold06 &lt;tibble [2 × 4]&gt; &lt;tibble [0 × 3]&gt; &lt;tibble&gt;    
 7 &lt;split [2108/234]&gt; Fold07 &lt;tibble [2 × 4]&gt; &lt;tibble [0 × 3]&gt; &lt;tibble&gt;    
 8 &lt;split [2108/234]&gt; Fold08 &lt;tibble [2 × 4]&gt; &lt;tibble [0 × 3]&gt; &lt;tibble&gt;    
 9 &lt;split [2108/234]&gt; Fold09 &lt;tibble [2 × 4]&gt; &lt;tibble [0 × 3]&gt; &lt;tibble&gt;    
10 &lt;split [2108/234]&gt; Fold10 &lt;tibble [2 × 4]&gt; &lt;tibble [0 × 3]&gt; &lt;tibble&gt;    </code></pre>
</div>
</div>
<p>Chociaż te kolumny listy mogą wyglądać zniechęcająco, można je łatwo przekonfigurować za pomocą <code>tidymodels</code>. Na przykład, aby zwrócić metryki wydajności w bardziej użytecznym formacie:</p>
<div class="cell">
<details open="" class="code-fold"><summary>Kod</summary><div class="sourceCode" id="cb27"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu">collect_metrics</span><span class="op">(</span><span class="va">rf_res</span><span class="op">)</span></span></code><button title="Kopiuj do schowka" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output cell-output-stdout">
<pre><code># A tibble: 2 × 6
  .metric .estimator   mean     n std_err .config             
  &lt;chr&gt;   &lt;chr&gt;       &lt;dbl&gt; &lt;int&gt;   &lt;dbl&gt; &lt;chr&gt;               
1 rmse    standard   0.0719    10 0.00322 Preprocessor1_Model1
2 rsq     standard   0.839     10 0.00776 Preprocessor1_Model1</code></pre>
</div>
</div>
<p>Aby uzyskać metryki dla każdej próby, należy użyć opcji <code>summarize = FALSE</code>. Natomiast aby uzyskać predykcje z poszczególnych foldów użyjemy:</p>
<div class="cell">
<details open="" class="code-fold"><summary>Kod</summary><div class="sourceCode" id="cb29"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">assess_res</span> <span class="op">&lt;-</span> <span class="fu">collect_predictions</span><span class="op">(</span><span class="va">rf_res</span><span class="op">)</span></span>
<span><span class="va">assess_res</span></span></code><button title="Kopiuj do schowka" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output cell-output-stdout">
<pre><code># A tibble: 2,342 × 5
   .pred id      .row Sale_Price .config             
   &lt;dbl&gt; &lt;chr&gt;  &lt;int&gt;      &lt;dbl&gt; &lt;chr&gt;               
 1  5.10 Fold01    10       5.09 Preprocessor1_Model1
 2  5.06 Fold01    27       5.08 Preprocessor1_Model1
 3  5.11 Fold01    47       5.10 Preprocessor1_Model1
 4  5.04 Fold01    52       5.11 Preprocessor1_Model1
 5  5.14 Fold01    59       5    Preprocessor1_Model1
 6  4.99 Fold01    63       4.90 Preprocessor1_Model1
 7  5.10 Fold01    65       5.11 Preprocessor1_Model1
 8  4.90 Fold01    66       4.77 Preprocessor1_Model1
 9  5.15 Fold01    67       5.10 Preprocessor1_Model1
10  5.03 Fold01    68       5.10 Preprocessor1_Model1
# ℹ 2,332 more rows</code></pre>
</div>
</div>
<p>Kolumna <code>.row</code> jest liczbą całkowitą, która odpowiada numerowi wiersza oryginalnego zestawu treningowego, tak aby te wyniki mogły być odpowiednio połączone z oryginalnymi danymi.</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Wskazówka
</div>
</div>
<div class="callout-body-container callout-body">
<p>Dla niektórych metod resamplingu, takich jak <em>bootstrap</em> lub walidacja krzyżowa z powtórzeniami, otrzymamy wiele predykcji na wiersz oryginalnego zestawu treningowego. Aby uzyskać jedną statystykę (średnią z predykcji) użyj <code>collect_predictions(object, summarize = TRUE)</code>.</p>
</div>
</div>
<div class="cell">
<details open="" class="code-fold"><summary>Kod</summary><div class="sourceCode" id="cb31"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">assess_res</span> <span class="op">|&gt;</span></span>
<span>  <span class="fu">ggplot</span><span class="op">(</span><span class="fu">aes</span><span class="op">(</span>x <span class="op">=</span> <span class="va">Sale_Price</span>, y <span class="op">=</span> <span class="va">.pred</span><span class="op">)</span><span class="op">)</span> <span class="op">+</span> </span>
<span>  <span class="fu">geom_point</span><span class="op">(</span>alpha <span class="op">=</span> <span class="fl">.15</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu">geom_abline</span><span class="op">(</span>color <span class="op">=</span> <span class="st">"red"</span><span class="op">)</span> <span class="op">+</span> </span>
<span>  <span class="fu">coord_obs_pred</span><span class="op">(</span><span class="op">)</span> <span class="op">+</span> </span>
<span>  <span class="fu">ylab</span><span class="op">(</span><span class="st">"Predicted"</span><span class="op">)</span></span></code><button title="Kopiuj do schowka" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output-display">
<div id="fig-pred-obs" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-pred-obs-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="resampling2_files/figure-html/fig-pred-obs-1.png" class="lightbox" data-glightbox="description: .lightbox-desc-16" data-gallery="quarto-lightbox-gallery-16"><img src="resampling2_files/figure-html/fig-pred-obs-1.png" class="img-fluid figure-img" width="672"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-pred-obs-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Rys.&nbsp;7.9: Porównanie predykcji z modelu z obserwowanymi wartościami na podstawie wyników resamplingu
</figcaption></figure>
</div>
</div>
</div>
<p>W zbiorze treningowym znajdują się dwa domy o niskiej zaobserwowanej cenie sprzedaży, których cena jest znacznie zawyżona przez model. Które to domy? Dowiedzmy się tego z wyniku <code>assess_res</code>:</p>
<div class="cell">
<details open="" class="code-fold"><summary>Kod</summary><div class="sourceCode" id="cb32"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">over_predicted</span> <span class="op">&lt;-</span> </span>
<span>  <span class="va">assess_res</span> <span class="op">|&gt;</span> </span>
<span>  <span class="fu">mutate</span><span class="op">(</span>residual <span class="op">=</span> <span class="va">Sale_Price</span> <span class="op">-</span> <span class="va">.pred</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>  <span class="fu">arrange</span><span class="op">(</span><span class="fu">desc</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/MathFun.html">abs</a></span><span class="op">(</span><span class="va">residual</span><span class="op">)</span><span class="op">)</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>  <span class="fu">slice</span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="fl">2</span><span class="op">)</span></span>
<span><span class="va">over_predicted</span></span></code><button title="Kopiuj do schowka" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output cell-output-stdout">
<pre><code># A tibble: 2 × 6
  .pred id      .row Sale_Price .config              residual
  &lt;dbl&gt; &lt;chr&gt;  &lt;int&gt;      &lt;dbl&gt; &lt;chr&gt;                   &lt;dbl&gt;
1  4.95 Fold03    30       4.11 Preprocessor1_Model1   -0.844
2  4.92 Fold05   316       4.12 Preprocessor1_Model1   -0.807</code></pre>
</div>
<details open="" class="code-fold"><summary>Kod</summary><div class="sourceCode" id="cb34"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">ames_train</span> <span class="op">|&gt;</span></span>
<span>  <span class="fu">slice</span><span class="op">(</span><span class="va">over_predicted</span><span class="op">$</span><span class="va">.row</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>  <span class="fu">select</span><span class="op">(</span><span class="va">Gr_Liv_Area</span>, <span class="va">Neighborhood</span>, <span class="va">Year_Built</span>, <span class="va">Bedroom_AbvGr</span>, <span class="va">Full_Bath</span><span class="op">)</span></span></code><button title="Kopiuj do schowka" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output cell-output-stdout">
<pre><code># A tibble: 2 × 5
  Gr_Liv_Area Neighborhood           Year_Built Bedroom_AbvGr Full_Bath
        &lt;int&gt; &lt;fct&gt;                       &lt;int&gt;         &lt;int&gt;     &lt;int&gt;
1         832 Old_Town                     1923             2         1
2         733 Iowa_DOT_and_Rail_Road       1952             2         1</code></pre>
</div>
</div>
<p>Identyfikacja takich przykładów ze szczególnie słabym dopasowaniem może pomóc nam śledzić i badać, dlaczego te konkretne przewidywania są tak słabe.</p>
<p>Jeśli chcielibyśmy użyć zbioru walidacyjnego do oceny modelu, użyjemy:</p>
<div class="cell">
<details open="" class="code-fold"><summary>Kod</summary><div class="sourceCode" id="cb36"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">val_res</span> <span class="op">&lt;-</span> <span class="va">rf_wflow</span> <span class="op">|&gt;</span> </span>
<span>  <span class="fu">fit_resamples</span><span class="op">(</span>resamples <span class="op">=</span> <span class="va">val_set</span><span class="op">)</span></span>
<span><span class="va">val_res</span></span></code><button title="Kopiuj do schowka" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output cell-output-stdout">
<pre><code># Resampling results
# Validation Set Split (0.75/0.25)  
# A tibble: 1 × 4
  splits             id         .metrics         .notes          
  &lt;list&gt;             &lt;chr&gt;      &lt;list&gt;           &lt;list&gt;          
1 &lt;split [1756/586]&gt; validation &lt;tibble [2 × 4]&gt; &lt;tibble [0 × 3]&gt;</code></pre>
</div>
<details open="" class="code-fold"><summary>Kod</summary><div class="sourceCode" id="cb38"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu">collect_metrics</span><span class="op">(</span><span class="va">val_res</span><span class="op">)</span></span></code><button title="Kopiuj do schowka" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output cell-output-stdout">
<pre><code># A tibble: 2 × 6
  .metric .estimator   mean     n std_err .config             
  &lt;chr&gt;   &lt;chr&gt;       &lt;dbl&gt; &lt;int&gt;   &lt;dbl&gt; &lt;chr&gt;               
1 rmse    standard   0.0752     1      NA Preprocessor1_Model1
2 rsq     standard   0.827      1      NA Preprocessor1_Model1</code></pre>
</div>
</div>
<p>Jak widać wyniki te są zbliżone do otrzymanych z wykorzystaniem próby testowej.</p>
</section><section id="przetwarzanie-równoległe" class="level2 page-columns page-full" data-number="7.9"><h2 data-number="7.9" class="anchored" data-anchor-id="przetwarzanie-równoległe">
<span class="header-section-number">7.9</span> Przetwarzanie równoległe</h2>
<p>Pakiet <code>tune</code> używa pakietu <code>foreach</code> do przeprowadzenia obliczeń równoległych. Obliczenia te mogą być podzielone pomiędzy rdzenie procesora na tym samym komputerze lub na różnych komputerach, w zależności od wybranej technologii.</p>
<p>Liczbę dostępnych rdzeni można wykryć za pomocą:</p>
<div class="cell" data-evel="false">
<details open="" class="code-fold"><summary>Kod</summary><div class="sourceCode" id="cb40"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="co"># Liczba fizycznych rdzeni</span></span>
<span><span class="fu">parallel</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/r/parallel/detectCores.html">detectCores</a></span><span class="op">(</span>logical <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span></span></code><button title="Kopiuj do schowka" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output cell-output-stdout">
<pre><code>[1] 8</code></pre>
</div>
<details open="" class="code-fold"><summary>Kod</summary><div class="sourceCode" id="cb42"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="co"># liczba logicznych rdzeni  </span></span>
<span><span class="fu">parallel</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/r/parallel/detectCores.html">detectCores</a></span><span class="op">(</span>logical <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span></code><button title="Kopiuj do schowka" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output cell-output-stdout">
<pre><code>[1] 8</code></pre>
</div>
</div>
<p>Różnica między tymi dwoma wartościami jest związana z typem procesora. Na przykład większość procesorów Intela wykorzystuje <em>hyperthreading</em><a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>, który tworzy dwa wirtualne rdzenie dla każdego fizycznego rdzenia. Dodatkowe zasoby mogą poprawić wydajność, jednak rzadko można je stosować na wszystkich rdzeniach fizycznych, ponieważ pewne zasoby są potrzebne do obsługi <em>hyperthreadingu</em>.</p>
<div class="no-row-height column-margin column-container"><p><sup>2</sup>&nbsp;wielowątkowość współbieżna</p></div><p>W przypadku <code>fit_resamples()</code> i innych funkcji w pakiecie <code>tune</code>, przetwarzanie równoległe występuje, gdy użytkownik zarejestruje pakiet równoległego przetwarzania. Owe pakiety definiują sposób wykonywania przetwarzania równoległego. W systemach operacyjnych Unix i macOS jedną z metod podziału obliczeń jest rozgałęzienie wątków. Aby to umożliwić, załaduj pakiet <code>doMC</code> i zarejestruj liczbę równoległych rdzeni dla <code>foreach</code>:</p>
<div class="cell">
<details open="" class="code-fold"><summary>Kod</summary><div class="sourceCode" id="cb44"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="co"># tylko w Unix i macOS</span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va">doMC</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/doMC/man/registerDoMC.html">registerDoMC</a></span><span class="op">(</span>cores <span class="op">=</span> <span class="fl">4</span><span class="op">)</span></span></code><button title="Kopiuj do schowka" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>To daje instrukcje dla <code>fit_resamples()</code>, aby uruchomić 1/4 obliczeń na każdym z czterech rdzeni. Aby zresetować obliczenia do przetwarzania sekwencyjnego:</p>
<div class="cell">
<details open="" class="code-fold"><summary>Kod</summary><div class="sourceCode" id="cb45"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/pkg/foreach/man/registerDoSEQ.html">registerDoSEQ</a></span><span class="op">(</span><span class="op">)</span></span></code><button title="Kopiuj do schowka" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Alternatywnie, inne podejście do paralelizacji obliczeń wykorzystuje gniazda sieciowe. Pakiet <code>doParallel</code> umożliwia tę metodę (możliwą do wykorzystania przez wszystkie systemy operacyjne):</p>
<div class="cell">
<details open="" class="code-fold"><summary>Kod</summary><div class="sourceCode" id="cb46"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://github.com/RevolutionAnalytics/doparallel">doParallel</a></span><span class="op">)</span></span>
<span></span>
<span><span class="va">cl</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/parallel/makeCluster.html">makePSOCKcluster</a></span><span class="op">(</span><span class="fl">4</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/doParallel/man/registerDoParallel.html">registerDoParallel</a></span><span class="op">(</span><span class="va">cl</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># fit_resamples()...</span></span>
<span></span>
<span><span class="fu"><a href="https://rdrr.io/r/parallel/makeCluster.html">stopCluster</a></span><span class="op">(</span><span class="va">cl</span><span class="op">)</span></span></code><button title="Kopiuj do schowka" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Jeszcze innym pakietem R, który ułatwia przetwarzanie równoległe, jest pakiet <code>future</code>. Podobnie jak <code>foreach</code>, zapewnia on wykonywanie równoległych obliczeń na wybranej liczbie rdzeni. Pakiet ten jest używany w połączeniu z <code>foreach</code> poprzez pakiet <code>doFuture</code>.</p>
<p>Przetwarzanie równoległe z pakietem <code>tune</code> ma tendencję do zapewnienia liniowego przyspieszenia dla pierwszych kilku rdzeni. Oznacza to, że przy dwóch rdzeniach obliczenia są dwukrotnie szybsze. W zależności od typu danych i modelu, wzrost prędkości spada, tak że po włączeniu czterech czy pięciu rdzeni prędkość nie wzrośnie 4- czy 5-krotnie. Użycie większej liczby rdzeni nadal będzie skracać czas potrzebny do wykonania zadania; po prostu ich efektywność spada wraz z włączeniem dodatkowych rdzeni.</p>
<p>Zakończmy ostatnią uwagą na temat obliczeń równoległych. Dla każdej z tych technologii, wymagania dotyczące pamięci wzrastają z każdym dodatkowym rdzeniem. Na przykład, jeśli bieżący zestaw danych zajmuje 2 GB pamięci i używane są trzy rdzenie, całkowite zapotrzebowanie na pamięć wyniesie 8 GB (2 dla każdego procesu roboczego plus oryginał). Użycie zbyt wielu rdzeni może spowodować znaczne spowolnienie obliczeń (i komputera).</p>
</section><section id="przechowywanie-wyników-resamplingu" class="level2" data-number="7.10"><h2 data-number="7.10" class="anchored" data-anchor-id="przechowywanie-wyników-resamplingu">
<span class="header-section-number">7.10</span> Przechowywanie wyników resamplingu</h2>
<p>Modele utworzone podczas próbkowania nie są zapisywane. Modele te są trenowane w celu oceny dopasowania i zazwyczaj nie potrzebujemy ich po obliczeniu miar dopasowania. Jeśli określone podejście do modelowania okaże się najlepszą opcją dla naszego zestawu danych, wtedy najlepszym wyborem jest ponowne dopasowanie modelu do całego zestawu uczącego, aby parametry modelu mogły być oszacowane przy użyciu większej ilości danych.</p>
<p>Podczas gdy te modele utworzone podczas resamplingu nie są zachowywane, istnieje metoda na zapisanie ich lub części składników. Opcja <code>extract</code> funkcji <code>control_resamples()</code> określa funkcję, która przyjmuje pojedynczy argument; my użyjemy <code>x</code>. Gdy zostanie wykonana, <code>x</code> przekazuje w wyniku dopasowany obiekt przepływu, niezależnie od tego, czy przekazałeś <code>fit_resamples()</code> z przepływem. Przypomnijmy, że pakiet <code>workflows</code> posiada funkcje, które mogą wyciągać różne składniki obiektów (np. model, recepturę itp.).</p>
<div class="cell">
<details open="" class="code-fold"><summary>Kod</summary><div class="sourceCode" id="cb47"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">ames_rec</span> <span class="op">&lt;-</span> </span>
<span>  <span class="fu">recipe</span><span class="op">(</span><span class="va">Sale_Price</span> <span class="op">~</span> <span class="va">Neighborhood</span> <span class="op">+</span> <span class="va">Gr_Liv_Area</span> <span class="op">+</span> <span class="va">Year_Built</span> <span class="op">+</span> <span class="va">Bldg_Type</span> <span class="op">+</span> </span>
<span>           <span class="va">Latitude</span> <span class="op">+</span> <span class="va">Longitude</span>, data <span class="op">=</span> <span class="va">ames_train</span><span class="op">)</span> <span class="op">%&gt;%</span></span>
<span>  <span class="fu">step_other</span><span class="op">(</span><span class="va">Neighborhood</span>, threshold <span class="op">=</span> <span class="fl">0.01</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>  <span class="fu">step_dummy</span><span class="op">(</span><span class="fu">all_nominal_predictors</span><span class="op">(</span><span class="op">)</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>  <span class="fu">step_interact</span><span class="op">(</span> <span class="op">~</span> <span class="va">Gr_Liv_Area</span><span class="op">:</span><span class="fu">starts_with</span><span class="op">(</span><span class="st">"Bldg_Type_"</span><span class="op">)</span> <span class="op">)</span> <span class="op">|&gt;</span></span>
<span>  <span class="fu">step_ns</span><span class="op">(</span><span class="va">Latitude</span>, <span class="va">Longitude</span>, deg_free <span class="op">=</span> <span class="fl">20</span><span class="op">)</span></span>
<span></span>
<span><span class="va">lm_wflow</span> <span class="op">&lt;-</span>  </span>
<span>  <span class="fu">workflow</span><span class="op">(</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>  <span class="fu">add_recipe</span><span class="op">(</span><span class="va">ames_rec</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>  <span class="fu">add_model</span><span class="op">(</span><span class="fu">linear_reg</span><span class="op">(</span><span class="op">)</span> <span class="op">|&gt;</span><span class="fu">set_engine</span><span class="op">(</span><span class="st">"lm"</span><span class="op">)</span><span class="op">)</span> </span>
<span></span>
<span><span class="va">lm_fit</span> <span class="op">&lt;-</span> <span class="va">lm_wflow</span> <span class="op">|&gt;</span> </span>
<span>  <span class="fu">fit</span><span class="op">(</span>data <span class="op">=</span> <span class="va">ames_train</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># wyciągnijmy przepis</span></span>
<span><span class="fu">extract_recipe</span><span class="op">(</span><span class="va">lm_fit</span>, estimated <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># wyciągnijmy model</span></span>
<span><span class="va">get_model</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">x</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="fu">extract_fit_parsnip</span><span class="op">(</span><span class="va">x</span><span class="op">)</span> <span class="op">|&gt;</span> </span>
<span>    <span class="fu">tidy</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="op">}</span></span>
<span></span>
<span><span class="co"># tak działa na pojedynczym modelu</span></span>
<span><span class="fu">get_model</span><span class="op">(</span><span class="va">lm_fit</span><span class="op">)</span></span></code><button title="Kopiuj do schowka" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output cell-output-stdout">
<pre><code># A tibble: 72 × 5
   term                             estimate  std.error statistic   p.value
   &lt;chr&gt;                               &lt;dbl&gt;      &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;
 1 (Intercept)                      1.25     0.305          4.09  4.42e-  5
 2 Gr_Liv_Area                      0.000163 0.00000433    37.6   5.23e-241
 3 Year_Built                       0.00191  0.000143      13.4   2.23e- 39
 4 Neighborhood_College_Creek       0.0131   0.0343         0.382 7.03e-  1
 5 Neighborhood_Old_Town           -0.0559   0.0129        -4.35  1.44e-  5
 6 Neighborhood_Edwards            -0.0799   0.0282        -2.84  4.60e-  3
 7 Neighborhood_Somerset            0.0777   0.0198         3.93  8.68e-  5
 8 Neighborhood_Northridge_Heights  0.156    0.0287         5.43  6.24e-  8
 9 Neighborhood_Gilbert             0.0322   0.0226         1.43  1.54e-  1
10 Neighborhood_Sawyer             -0.0911   0.0266        -3.43  6.23e-  4
# ℹ 62 more rows</code></pre>
</div>
<details open="" class="code-fold"><summary>Kod</summary><div class="sourceCode" id="cb49"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="co"># a tak na wyniku resamplingu</span></span>
<span><span class="va">ctrl</span> <span class="op">&lt;-</span> <span class="fu">control_resamples</span><span class="op">(</span>extract <span class="op">=</span> <span class="va">get_model</span><span class="op">)</span></span>
<span></span>
<span><span class="va">lm_res</span> <span class="op">&lt;-</span> <span class="va">lm_wflow</span> <span class="op">|&gt;</span> </span>
<span>  <span class="fu">fit_resamples</span><span class="op">(</span>resamples <span class="op">=</span> <span class="va">ames_folds</span>, control <span class="op">=</span> <span class="va">ctrl</span><span class="op">)</span></span>
<span><span class="va">lm_res</span></span></code><button title="Kopiuj do schowka" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output cell-output-stdout">
<pre><code># Resampling results
# 10-fold cross-validation 
# A tibble: 10 × 5
   splits             id     .metrics         .notes           .extracts       
   &lt;list&gt;             &lt;chr&gt;  &lt;list&gt;           &lt;list&gt;           &lt;list&gt;          
 1 &lt;split [2107/235]&gt; Fold01 &lt;tibble [2 × 4]&gt; &lt;tibble [0 × 3]&gt; &lt;tibble [1 × 2]&gt;
 2 &lt;split [2107/235]&gt; Fold02 &lt;tibble [2 × 4]&gt; &lt;tibble [0 × 3]&gt; &lt;tibble [1 × 2]&gt;
 3 &lt;split [2108/234]&gt; Fold03 &lt;tibble [2 × 4]&gt; &lt;tibble [0 × 3]&gt; &lt;tibble [1 × 2]&gt;
 4 &lt;split [2108/234]&gt; Fold04 &lt;tibble [2 × 4]&gt; &lt;tibble [0 × 3]&gt; &lt;tibble [1 × 2]&gt;
 5 &lt;split [2108/234]&gt; Fold05 &lt;tibble [2 × 4]&gt; &lt;tibble [0 × 3]&gt; &lt;tibble [1 × 2]&gt;
 6 &lt;split [2108/234]&gt; Fold06 &lt;tibble [2 × 4]&gt; &lt;tibble [0 × 3]&gt; &lt;tibble [1 × 2]&gt;
 7 &lt;split [2108/234]&gt; Fold07 &lt;tibble [2 × 4]&gt; &lt;tibble [0 × 3]&gt; &lt;tibble [1 × 2]&gt;
 8 &lt;split [2108/234]&gt; Fold08 &lt;tibble [2 × 4]&gt; &lt;tibble [0 × 3]&gt; &lt;tibble [1 × 2]&gt;
 9 &lt;split [2108/234]&gt; Fold09 &lt;tibble [2 × 4]&gt; &lt;tibble [0 × 3]&gt; &lt;tibble [1 × 2]&gt;
10 &lt;split [2108/234]&gt; Fold10 &lt;tibble [2 × 4]&gt; &lt;tibble [0 × 3]&gt; &lt;tibble [1 × 2]&gt;</code></pre>
</div>
</div>
<p>Teraz z każdego folda możemy wyciągnąć szczegóły modelu.</p>
<div class="cell">
<details open="" class="code-fold"><summary>Kod</summary><div class="sourceCode" id="cb51"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">lm_res</span><span class="op">$</span><span class="va">.extracts</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span></span></code><button title="Kopiuj do schowka" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output cell-output-stdout">
<pre><code>[[1]]
# A tibble: 72 × 5
   term                             estimate  std.error statistic   p.value
   &lt;chr&gt;                               &lt;dbl&gt;      &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;
 1 (Intercept)                      1.32     0.319          4.13  3.72e-  5
 2 Gr_Liv_Area                      0.000169 0.00000465    36.3   1.38e-222
 3 Year_Built                       0.00187  0.000150      12.4   2.85e- 34
 4 Neighborhood_College_Creek       0.0187   0.0362         0.517 6.06e-  1
 5 Neighborhood_Old_Town           -0.0521   0.0136        -3.84  1.29e-  4
 6 Neighborhood_Edwards            -0.0737   0.0297        -2.49  1.30e-  2
 7 Neighborhood_Somerset            0.0763   0.0213         3.58  3.56e-  4
 8 Neighborhood_Northridge_Heights  0.151    0.0305         4.96  7.77e-  7
 9 Neighborhood_Gilbert             0.0287   0.0242         1.19  2.35e-  1
10 Neighborhood_Sawyer             -0.0861   0.0280        -3.08  2.12e-  3
# ℹ 62 more rows</code></pre>
</div>
</div>
<p>Może się to wydawać zawiłą metodą zapisywania wyników modelu. Jednakże, <code>extract</code> jest elastyczna i nie zakłada, że użytkownik będzie zapisywał tylko jedną <code>tibble</code> dla każdej próbki. Na przykład, metoda <code>tidy()</code> może być uruchomiona zarówno na przepisie jak i na modelu. W tym przypadku zwrócona zostanie lista dwóch <code>tibble</code>.</p>
<div class="cell">
<details open="" class="code-fold"><summary>Kod</summary><div class="sourceCode" id="cb53"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">all_coef</span> <span class="op">&lt;-</span> <span class="fu">map_dfr</span><span class="op">(</span><span class="va">lm_res</span><span class="op">$</span><span class="va">.extracts</span>, <span class="op">~</span> <span class="va">.x</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/stats/filter.html">filter</a></span><span class="op">(</span><span class="va">all_coef</span>, <span class="va">term</span> <span class="op">==</span> <span class="st">"Year_Built"</span><span class="op">)</span></span></code><button title="Kopiuj do schowka" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output cell-output-stdout">
<pre><code># A tibble: 10 × 5
   term       estimate std.error statistic  p.value
   &lt;chr&gt;         &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;
 1 Year_Built  0.00187  0.000150      12.4 2.85e-34
 2 Year_Built  0.00190  0.000153      12.5 2.06e-34
 3 Year_Built  0.00191  0.000144      13.2 1.74e-38
 4 Year_Built  0.00192  0.000151      12.8 6.61e-36
 5 Year_Built  0.00188  0.000151      12.4 2.75e-34
 6 Year_Built  0.00210  0.000152      13.8 9.75e-42
 7 Year_Built  0.00186  0.000151      12.3 1.23e-33
 8 Year_Built  0.00200  0.000154      13.0 4.43e-37
 9 Year_Built  0.00191  0.000153      12.5 1.97e-34
10 Year_Built  0.00188  0.000154      12.2 3.47e-33</code></pre>
</div>
</div>


<div class="hidden" aria-hidden="true">
<span class="glightbox-desc lightbox-desc-3">Rys.&nbsp;7.1: Przykład podziału zbioru danych z wykorzystaniem resamplingu</span>
<span class="glightbox-desc lightbox-desc-5">Rys.&nbsp;7.2: 3-krotny sprawdzian krzyżowy</span>
<span class="glightbox-desc lightbox-desc-6">Rys.&nbsp;7.3: Zastosowanie foldów w uczeniu i ocenie dopasowania modeli</span>
<span class="glightbox-desc lightbox-desc-9">Rys.&nbsp;7.4: Wielkość błędu standardowego estymacji w zależności od liczby powtórzeń walidacji krzyżowych</span>
<span class="glightbox-desc lightbox-desc-11">Rys.&nbsp;7.5: Podział zbiorów na uczący, testowy i walidacyjny</span>
<span class="glightbox-desc lightbox-desc-12">Rys.&nbsp;7.6: Podział na trzy zbiory</span>
<span class="glightbox-desc lightbox-desc-13">Rys.&nbsp;7.7: Trzy próby bootstrapowe</span>
<span class="glightbox-desc lightbox-desc-14">Rys.&nbsp;7.8: Próbkowanie kroczące ze źródła</span>
<span class="glightbox-desc lightbox-desc-16">Rys.&nbsp;7.9: Porównanie predykcji z modelu z obserwowanymi wartościami na podstawie wyników resamplingu</span>
</div>
<div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list" style="display: none">
<div id="ref-davison1997" class="csl-entry" role="listitem">
Davison, A. C., i D. V. Hinkley. 1997. <span>„Bootstrap Methods and their Application”</span>, październik. <a href="https://doi.org/10.1017/cbo9780511802843">https://doi.org/10.1017/cbo9780511802843</a>.
</div>
<div id="ref-hyndman" class="csl-entry" role="listitem">
Hyndman, Robin John, i George Athanasopoulos. 2018. <em>Forecasting: Principles and Practice</em>. 2nd wyd. Australia: OTexts.
</div>
<div id="ref-xu2001" class="csl-entry" role="listitem">
Xu, Qing-Song, i Yi-Zeng Liang. 2001. <span>„Monte Carlo Cross Validation”</span>. <em>Chemometrics and Intelligent Laboratory Systems</em> 56 (1): 1–11. <a href="https://doi.org/10.1016/s0169-7439(00)00122-2">https://doi.org/10.1016/s0169-7439(00)00122-2</a>.
</div>
</div>
</section></main><!-- /main --><script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
    const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
    const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
    let newTheme = '';
    if(darkModeDefault) {
      newTheme = isAlternate ? baseTheme : alternateTheme;
    } else {
      newTheme = isAlternate ? alternateTheme : baseTheme;
    }
    const changeGiscusTheme = () => {
      // From: https://github.com/giscus/giscus/issues/336
      const sendMessage = (message) => {
        const iframe = document.querySelector('iframe.giscus-frame');
        if (!iframe) return;
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
      sendMessage({
        setConfig: {
          theme: newTheme
        }
      });
    }
    const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
    if (isGiscussLoaded) {
      changeGiscusTheme();
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  const darkModeDefault = false;
  let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
    toggleGiscusIfUsed(toAlternate, darkModeDefault);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Skopiowano!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Skopiowano!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script><nav class="page-navigation"><div class="nav-page nav-page-previous">
      <a href="./tidymodels.html" class="pagination-link  aria-label=" z="">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Praca z <code>tidymodels</code></span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./comparison.html" class="pagination-link" aria-label="<span class='chapter-number'>8</span>&nbsp; <span class='chapter-title'>Porównanie modeli</span>">
        <span class="nav-page-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Porównanie modeli</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->
<footer class="footer"><div class="nav-footer">
    <div class="nav-footer-left">
<p>Metody walidacji modeli statystycznych, Dariusz Majerek</p>
</div>   
    <div class="nav-footer-center">
      &nbsp;
    <div class="toc-actions d-sm-block d-md-none"><ul><li><a href="https://github.com/dax44/ModelsValidation/issues/new" class="toc-action"><i class="bi bi-github"></i>Zgłoś problem</a></li></ul></div></div>
    <div class="nav-footer-right">
<p>Książka została napisana w <a href="https://quarto.org/">Quarto</a></p>
</div>
  </div>
</footer><script>var lightboxQuarto = GLightbox({"loop":false,"closeEffect":"zoom","selector":".lightbox","descPosition":"bottom","openEffect":"zoom"});
window.onload = () => {
  lightboxQuarto.on('slide_before_load', (data) => {
    const { slideIndex, slideNode, slideConfig, player, trigger } = data;
    const href = trigger.getAttribute('href');
    if (href !== null) {
      const imgEl = window.document.querySelector(`a[href="${href}"] img`);
      if (imgEl !== null) {
        const srcAttr = imgEl.getAttribute("src");
        if (srcAttr && srcAttr.startsWith("data:")) {
          slideConfig.href = srcAttr;
        }
      }
    } 
  });

  lightboxQuarto.on('slide_after_load', (data) => {
    const { slideIndex, slideNode, slideConfig, player, trigger } = data;
    if (window.Quarto?.typesetMath) {
      window.Quarto.typesetMath(slideNode);
    }
  });

};
          </script>


</body></html>