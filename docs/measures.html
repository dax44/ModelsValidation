<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="pl" xml:lang="pl"><head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.299">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<title>Metody walidacji modeli statystycznych - 4&nbsp; Przegląd miar dopasowania modelu</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>

<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./resampling.html" rel="next">
<link href="./infer.html" rel="prev">
<link href="./images/logo2.png" rel="icon" type="image/png">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="site_libs/bootstrap/bootstrap-dark.min.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark"><script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 20,
  "language": {
    "search-no-results-text": "Brak wyników",
    "search-matching-documents-text": "dopasowane dokumenty",
    "search-copy-link-title": "Kopiuj link do wyszukiwania",
    "search-hide-matches-text": "Ukryj dodatkowe dopasowania",
    "search-more-match-text": "więcej dopasowań w tym dokumencie",
    "search-more-matches-text": "więcej dopasowań w tym dokumencie",
    "search-clear-button-title": "Wyczyść",
    "search-detached-cancel-button-title": "Anuluj",
    "search-submit-button-title": "Zatwierdź"
  }
}</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>
</head>
<body class="nav-sidebar floating slimcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top"><nav class="quarto-secondary-nav"><div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Przełącz pasek boczny" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
      <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./measures.html"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Przegląd miar dopasowania modelu</span></a></li></ol></nav>
      <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Przełącz pasek boczny" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
      </a>
      <button type="button" class="btn quarto-search-button" aria-label="Szukaj" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav></header><!-- content --><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal sidebar-navigation floating overflow-auto"><div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Metody walidacji modeli statystycznych</a> 
        <div class="sidebar-tools-main tools-wide">
    <a href="https://twitter.com" title="" class="quarto-navigation-tool px-1" aria-label=""><i class="bi bi-twitter"></i></a>
    <a href="https://github.com/dax44/ModelsValidation/" title="Source Code" class="quarto-navigation-tool px-1" aria-label="Source Code"><i class="bi bi-github"></i></a>
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Przełącz tryb ciemny"><i class="bi"></i></a>
  <a href="" class="quarto-reader-toggle quarto-navigation-tool px-1" onclick="window.quartoToggleReader(); return false;" title="Przełącz tryb czytnika">
  <div class="quarto-reader-toggle-btn">
  <i class="bi"></i>
  </div>
</a>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Szukaj"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
<li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Wprowadzenie</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./intro.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Ekosystem</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./modeling.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Modelowanie statystyczne</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./infer.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Modele inferencyjne</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./measures.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Przegląd miar dopasowania modelu</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./resampling.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Zarządzanie danymi</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./tidymodels.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Praca z <code>tidymodels</code></span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./resampling2.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Metody próbkowania</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./comparison.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Porównanie modeli</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./tuning.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">Optymalizacja modeli</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./grid_search.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">Dostrajanie z przeszukiwaniem siatki</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./parallel.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">11</span>&nbsp; <span class="chapter-title">Paralelizacja resamplingu</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./iterative.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">12</span>&nbsp; <span class="chapter-title">Przeszukiwanie iteracyjne</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./example.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">13</span>&nbsp; <span class="chapter-title">Poszukiwanie optymalnego modelu</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./dimensionality.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">14</span>&nbsp; <span class="chapter-title">Redukcja wymiarowości</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./imbalance.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">15</span>&nbsp; <span class="chapter-title">Nierównowaga klas w zadaniu klasyfikacyjnym</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./references.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">References</span></a>
  </div>
</li>
    </ul>
</div>
</nav><div id="quarto-sidebar-glass" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active"><h2 id="toc-title">Spis treści</h2>
   
  <ul>
<li>
<a href="#miary-dopasowania-modeli-regresyjnych" id="toc-miary-dopasowania-modeli-regresyjnych" class="nav-link active" data-scroll-target="#miary-dopasowania-modeli-regresyjnych"><span class="header-section-number">4.1</span> Miary dopasowania modeli regresyjnych</a>
  <ul class="collapse">
<li><a href="#r2" id="toc-r2" class="nav-link" data-scroll-target="#r2"><span class="header-section-number">4.1.1</span> <span class="math inline">\(R^2\)</span></a></li>
  <li><a href="#rmse" id="toc-rmse" class="nav-link" data-scroll-target="#rmse"><span class="header-section-number">4.1.2</span> RMSE</a></li>
  <li><a href="#mse" id="toc-mse" class="nav-link" data-scroll-target="#mse"><span class="header-section-number">4.1.3</span> MSE</a></li>
  <li><a href="#mae" id="toc-mae" class="nav-link" data-scroll-target="#mae"><span class="header-section-number">4.1.4</span> MAE</a></li>
  <li><a href="#mape" id="toc-mape" class="nav-link" data-scroll-target="#mape"><span class="header-section-number">4.1.5</span> MAPE</a></li>
  <li><a href="#mase" id="toc-mase" class="nav-link" data-scroll-target="#mase"><span class="header-section-number">4.1.6</span> MASE</a></li>
  <li><a href="#mpe" id="toc-mpe" class="nav-link" data-scroll-target="#mpe"><span class="header-section-number">4.1.7</span> MPE</a></li>
  <li><a href="#msd" id="toc-msd" class="nav-link" data-scroll-target="#msd"><span class="header-section-number">4.1.8</span> MSD</a></li>
  <li><a href="#funkcja-straty-hubera" id="toc-funkcja-straty-hubera" class="nav-link" data-scroll-target="#funkcja-straty-hubera"><span class="header-section-number">4.1.9</span> Funkcja straty Hubera</a></li>
  <li><a href="#funkcja-straty-pseudo-hubera" id="toc-funkcja-straty-pseudo-hubera" class="nav-link" data-scroll-target="#funkcja-straty-pseudo-hubera"><span class="header-section-number">4.1.10</span> Funkcja straty Pseudo-Hubera</a></li>
  <li><a href="#logarytm-funkcji-straty-dla-rozk%C5%82adu-poissona" id="toc-logarytm-funkcji-straty-dla-rozkładu-poissona" class="nav-link" data-scroll-target="#logarytm-funkcji-straty-dla-rozk%C5%82adu-poissona"><span class="header-section-number">4.1.11</span> Logarytm funkcji straty dla rozkładu Poissona</a></li>
  <li><a href="#smape" id="toc-smape" class="nav-link" data-scroll-target="#smape"><span class="header-section-number">4.1.12</span> SMAPE</a></li>
  <li><a href="#rpd" id="toc-rpd" class="nav-link" data-scroll-target="#rpd"><span class="header-section-number">4.1.13</span> RPD</a></li>
  <li><a href="#rpiq" id="toc-rpiq" class="nav-link" data-scroll-target="#rpiq"><span class="header-section-number">4.1.14</span> RPIQ</a></li>
  <li><a href="#ccc" id="toc-ccc" class="nav-link" data-scroll-target="#ccc"><span class="header-section-number">4.1.15</span> CCC</a></li>
  <li><a href="#podsumowanie-miar-dla-modeli-regresyjnych" id="toc-podsumowanie-miar-dla-modeli-regresyjnych" class="nav-link" data-scroll-target="#podsumowanie-miar-dla-modeli-regresyjnych"><span class="header-section-number">4.1.16</span> Podsumowanie miar dla modeli regresyjnych</a></li>
  </ul>
</li>
  <li>
<a href="#miary-dopasowania-modeli-klasyfikacyjnych" id="toc-miary-dopasowania-modeli-klasyfikacyjnych" class="nav-link" data-scroll-target="#miary-dopasowania-modeli-klasyfikacyjnych"><span class="header-section-number">4.2</span> Miary dopasowania modeli klasyfikacyjnych</a>
  <ul class="collapse">
<li><a href="#miary-dopasowania-dla-modeli-ze-zmienn%C4%85-wynikow%C4%85-wieloklasow%C4%85" id="toc-miary-dopasowania-dla-modeli-ze-zmienną-wynikową-wieloklasową" class="nav-link" data-scroll-target="#miary-dopasowania-dla-modeli-ze-zmienn%C4%85-wynikow%C4%85-wieloklasow%C4%85"><span class="header-section-number">4.2.1</span> Miary dopasowania dla modeli ze zmienną wynikową wieloklasową</a></li>
  </ul>
</li>
  <li><a href="#uwagi-ko%C5%84cowe" id="toc-uwagi-końcowe" class="nav-link" data-scroll-target="#uwagi-ko%C5%84cowe"><span class="header-section-number">4.3</span> Uwagi końcowe</a></li>
  </ul><div class="toc-actions"><div><i class="bi bi-github"></i></div><div class="action-links"><p><a href="https://github.com/dax44/ModelsValidation/issues/new" class="toc-action">Zgłoś problem</a></p></div></div></nav>
    </div>
<!-- main -->
<main class="content page-columns page-full" id="quarto-document-content"><header id="title-block-header" class="quarto-title-block default"><div class="quarto-title">
<h1 class="title">
<span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Przegląd miar dopasowania modelu</span>
</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  

</header><blockquote class="blockquote">
<p><em>Wszystkie modele są błędne, ale niektóre są przydatne</em> - George E.P. Box</p>
</blockquote>
<p>Ocenę jakości dopasowania modelu można dokonywać na różne sposoby:</p>
<ul>
<li>porównując przewidywaną klasę lub wartość na podstawie modelu z obserwowaną prawdziwą klasą lub wartością;</li>
<li>korzystając z ilustracji graficznej przedstawiając np. na osi odciętych wartości przewidywane na podstawie modelu, a na osi rzędnych wartości obserwowane w danych<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>; choć można się też spotkać z innymi wykresami, jak np. krzywe <em>ROC</em>, czy <em>Precision-Recall</em>;</li>
<li>przedstawić klasyfikację w postaci macierzy błędnych klasyfikacji (ang. <em>confusion matrix</em>);</li>
<li>najczęściej można się jednak spotkać z podejściem wykorzystującym różnego rodzaju miarami dopasowania modelu.</li>
</ul>
<div class="no-row-height column-margin column-container"><li id="fn1"><p><sup>1</sup>&nbsp;dotyczy to modeli regresyjnych</p></li></div><div class="page-columns page-full"><p>W tym rozdziale przedstawimy najpowszechniej stosowane miary dopasowania modelu w podziale na modele regresyjne i klasyfikacyjne. Przy czym w rodzinie modeli klasyfikacyjnych można wyszczególnić podklasę modeli, dla których zmienna wynikowa jest binarna. Modele ze zmienną wynikową binarną stanowią oddzielną klasę w kontekście dopasowania, ponieważ stosuje się wówczas inne miary dopasowania. Co prawda miary te można zastosować również w przypadku zmiennej wynikowej o większej liczbie kategorii<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>, ale wymaga to wówczas przyjęcia dodatkowych umów w jaki sposób je stosować, a sposoby te nie są jednoznaczne.</p><div class="no-row-height column-margin column-container"><li id="fn2"><p><sup>2</sup>&nbsp;czyli większej niż dwie</p></li></div></div>

<div class="no-row-height column-margin column-container"><div class="">
<p><img src="https://thumbs.gfycat.com/AdorableElegantGreatargus-max-1mb.gif" class="img-fluid"></p>
</div></div><section id="miary-dopasowania-modeli-regresyjnych" class="level2 page-columns page-full" data-number="4.1"><h2 data-number="4.1" class="anchored" data-anchor-id="miary-dopasowania-modeli-regresyjnych">
<span class="header-section-number">4.1</span> Miary dopasowania modeli regresyjnych</h2>
<p>Przegląd zaczniemy od najlepiej znanych miar, a skończymy na rzadziej stosowanych, jak funkcja straty Hubera.</p>
<section id="r2" class="level3 page-columns page-full" data-number="4.1.1"><h3 data-number="4.1.1" class="anchored" data-anchor-id="r2">
<span class="header-section-number">4.1.1</span> <span class="math inline">\(R^2\)</span>
</h3>
<p>Miara stosowana najczęściej do oceny dopasowania modeli liniowych, a definiowana jako:</p>
<p><span id="eq-r2trad"><span class="math display">\[
R^2=1-\frac{\sum_i(y_i-\hat{y}_i)^2}{\sum_i(y_i-\bar{y})^2},
\tag{4.1}\]</span></span></p>
<div class="page-columns page-full"><p>gdzie <span class="math inline">\(\hat{y}_i\)</span> jest <span class="math inline">\(i\)</span>-tą wartością przewidywaną na podstawie modelu, <span class="math inline">\(\bar{y}\)</span> jest średnią zmiennej wynikowej, a <span class="math inline">\(y_i\)</span> jest <span class="math inline">\(i\)</span>-tą wartością obserwowaną. Już na kursie modeli liniowych dowiedzieliśmy się o wadach tak zdefiniowanej miary. Wśród nich należy wymienić przede wszystkim fakt, iż dołączając do modelu zmienne, których zdolność predykcyjna jest nieistotna<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>, to i tak rośnie <span class="math inline">\(R^2\)</span></p><div class="no-row-height column-margin column-container"><li id="fn3"><p><sup>3</sup>&nbsp;czyli nie mają znaczenia w przewidywaniu wartości wynikowej</p></li></div></div>
<div class="page-columns page-full"><p>W przypadku modeli liniowych wprowadzaliśmy korektę eliminującą tą wadę, jednak w przypadku modeli predykcyjnych skorygowana miara <span class="math inline">\(R^2_{adj}\)</span> nie wystarcza. W sytuacji gdy modele mają bardzo słabą moc predykcyjną, czyli są np. drzewem regresyjnym bez żadnej reguły podziału<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a>, wówczas można otrzymać ujemne wartości obu miar. Zaleca się zatem wprowadzenie miary, która pozbawiona jest tej wady, a jednocześnie ma tą sama interpretację. Definiuję się ją następująco:</p><div class="no-row-height column-margin column-container"><li id="fn4"><p><sup>4</sup>&nbsp;drzewo składa się tylko z korzenia</p></li></div></div>
<p><span id="eq-r2cor"><span class="math display">\[
\tilde{R}^2=[\operatorname{Cor}(Y, \hat{Y})]^2.
\tag{4.2}\]</span></span></p>
<div class="page-columns page-full"><p>Miara zdefiniowana w (<a href="#eq-r2cor"><span>4.2</span></a>) zapewnia nam wartości w przedziale (0,1), a klasyczna miara (<a href="#eq-r2trad"><span>4.1</span></a>) nie <span class="citation" data-cites="kvalsethCautionaryNoteR21985">(<a href="references.html#ref-kvalsethCautionaryNoteR21985" role="doc-biblioref">Kvalseth 1985</a>)</span>. Tradycyjna jest zdefiniowana w bibliotece <code>yardstick</code><a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a> pod nazwą <code>rsq_trad</code>, natomiast miara oparta na korelacji jako <code>rsq</code>. Oczywiście interpretacja jest następująca, że jeśli wartość <span class="math inline">\(\tilde{R}^2\)</span> jest bliska 1, to model jest dobrze dopasowany, a bliskie 0 oznacza słabe dopasowanie.</p><div class="no-row-height column-margin column-container"><li id="fn5"><p><sup>5</sup>&nbsp;będącej częścią ekosystemu <code>tidymodels</code></p></li></div></div>
</section><section id="rmse" class="level3" data-number="4.1.2"><h3 data-number="4.1.2" class="anchored" data-anchor-id="rmse">
<span class="header-section-number">4.1.2</span> RMSE</h3>
<p>Inną powszechnie stosowaną miarą do oceny dopasowania modeli regresyjnych jest pierwiastek błędu średnio-kwadratowego (ang. <em>Root Mean Square Error</em>), zdefiniowany następująco:</p>
<p><span id="eq-rmse"><span class="math display">\[
RMSE = \sqrt{\frac{\sum_{i=1}^n(y_i-\hat{y}_i)^2}{n}},
\tag{4.3}\]</span></span></p>
<p>gdzie <span class="math inline">\(n\)</span> oznacza liczebność zbioru danych na jakim dokonywana jest ocena dopasowania. Im mniejsza jest wartość błędu RMSE tym lepiej dopasowany jest model. Niestety wadą tej miary jest brak odporności na wartości odstające. Błąd w tym przypadku jest mierzony w tych samych jednostkach co mierzona wielkość wynikowa <span class="math inline">\(Y\)</span>. Do wywołania jej używamy funkcji <code>rmse</code>.</p>
</section><section id="mse" class="level3 page-columns page-full" data-number="4.1.3"><h3 data-number="4.1.3" class="anchored" data-anchor-id="mse">
<span class="header-section-number">4.1.3</span> MSE</h3>
<p>Ściśle powiązaną miarą dopasowania modelu z RMSE jest błąd średnio-kwadratowy (ang. <em>Mean Square Error</em>). Oczywiście jest on definiowany jako kwadrat RMSE. Interpretacja jest podobna jak w przypadku RMSE. W tym przypadku błąd jest mierzony w jednostkach do kwadratu i również jak w przypadku RMSE miara ta jest wrażliwa na wartości odstające. Wywołujemy ją funkcją <code>mse</code>.</p>

<div class="no-row-height column-margin column-container"><div class="">
<p><img src="https://media.tenor.com/qsthhHhdjsQAAAAd/error-windows.gif" class="img-fluid"></p>
</div></div></section><section id="mae" class="level3" data-number="4.1.4"><h3 data-number="4.1.4" class="anchored" data-anchor-id="mae">
<span class="header-section-number">4.1.4</span> MAE</h3>
<p>Chcąc uniknąć (choćby w części) wrażliwości na wartości odstające stosuje się miarę średniego absolutnego błędu (ang. <em>Mean Absolut Error</em>). Definiujemy go następująco:</p>
<p><span id="eq-mae"><span class="math display">\[
MAE=\frac{\sum_{i=1}^n\vert y_i-\hat{y}_i\vert}{n}.
\tag{4.4}\]</span></span></p>
<p>Ponieważ wartości błędów <span class="math inline">\(y_i-\hat{y}_i\)</span> nie są podnoszone do kwadratu, to miara ta jest mniej wrażliwa na punkty odstające. Interpretacja jej jest podobna jak MSE i RMSE. Do wywołania jej używamy funkcji <code>mae</code>. Błąd w tym przypadku jest również mierzony w tych samych jednostkach co <span class="math inline">\(Y\)</span>.</p>
<p>Wymienione miary błędów są nieunormowane, a dopasowania modeli możemy dokonywać jedynie porównując wynik błędu z wartościami <span class="math inline">\(Y\)</span>, lub też przez porównanie miar dla różnych modeli.</p>
</section><section id="mape" class="level3" data-number="4.1.5"><h3 data-number="4.1.5" class="anchored" data-anchor-id="mape">
<span class="header-section-number">4.1.5</span> MAPE</h3>
<p>Średni bezwzględny błąd procentowy (ang. <em>Mean Absolute Percentage Error</em>) jest przykładem miary błędu wyrażanego w procentach. Definiuje się go następująco:</p>
<p><span id="eq-mape"><span class="math display">\[
MAPE=\frac{1}{n}\sum_{i=1}^n\left|\frac{y_i-\hat{y}_i}{y_i}\right|\cdot 100\%.
\tag{4.5}\]</span></span></p>
<p>Interpretujemy ten błąd podobnie jak poprzednie pomimo, że jest wyrażony w procentach. Do wywołania go w pakiecie <code>yardstick</code> używamy funkcji <code>mape</code>.</p>
</section><section id="mase" class="level3" data-number="4.1.6"><h3 data-number="4.1.6" class="anchored" data-anchor-id="mase">
<span class="header-section-number">4.1.6</span> MASE</h3>
<p>Średni bezwzględny błąd skalowany (ang. <em>Mean Absolute Scaled Error</em>) jest miarą dokładności prognoz. Została zaproponowana w 2005 roku przez statystyka Roba J. Hyndmana i profesora Anne B. Koehler, którzy opisali ją jako “ogólnie stosowaną miarę dokładności prognoz bez problemów widocznych w innych miarach” <span class="citation" data-cites="hyndmanAnotherLookMeasures2006">(<a href="references.html#ref-hyndmanAnotherLookMeasures2006" role="doc-biblioref">Hyndman i Koehler 2006</a>)</span>. Średni bezwzględny błąd skalowany ma korzystne właściwości w porównaniu z innymi metodami obliczania błędów prognoz, takimi jak RMSE, i dlatego jest zalecany do określania dokładności prognoz w szeregach czasowych <span class="citation" data-cites="fransesNoteMeanAbsolute2016">(<a href="references.html#ref-fransesNoteMeanAbsolute2016" role="doc-biblioref">Franses 2016</a>)</span>. Definiujemy go następująco</p>
<p><span id="eq-mase"><span class="math display">\[
MASE = \frac{\sum_{i=1}^n\vert y_i-\hat{y}_i\vert}{\sum_{i=1}^n\vert y_i-\bar{y}_i\vert}.
\tag{4.6}\]</span></span></p>
<p>Dla szeregów czasowych z sezonowością i bez sezonowości definiuje się go jeszcze nieco inaczej <span class="citation" data-cites="hyndmanAnotherLookMeasures2006 EvaluatingForecastAccuracy">(<a href="references.html#ref-hyndmanAnotherLookMeasures2006" role="doc-biblioref">Hyndman i Koehler 2006</a>; <a href="references.html#ref-EvaluatingForecastAccuracy" role="doc-biblioref"><em>3.4 <span>Evaluating</span> Forecast Accuracy | <span>Forecasting</span>: <span>Principles</span> and <span>Practice</span> (2nd Ed)</em>, b.d.</a>)</span>. Oczywiście interpretacja jest też podobna jak w przypadku innych miar błędów. Wywołujemy go funkcją <code>mase</code>.</p>
</section><section id="mpe" class="level3" data-number="4.1.7"><h3 data-number="4.1.7" class="anchored" data-anchor-id="mpe">
<span class="header-section-number">4.1.7</span> MPE</h3>
<p>Średni błąd procentowy (ang. <em>Mean Percentage Error</em>) jest miarą błędu względnego definiowaną nastepująco</p>
<p><span id="eq-mpe"><span class="math display">\[
MPE = \frac{1}{n}\sum_{i=1}^n\frac{y_i-\hat{y}_i}{y_i}.
\tag{4.7}\]</span></span></p>
<p>Ponieważ we wzorze wykorzystywane są rzeczywiste, a nie bezwzględne wartości błędów prognozy, dodatnie i ujemne błędy prognozy mogą się wzajemnie kompensować. W rezultacie wzór ten można wykorzystać jako miarę błędu systematycznego w prognozach. Wadą tej miary jest to, że jest ona zawsze określona, gdy pojedyncza wartość rzeczywista wynosi zero. Wywołujemy ją za pomocą <code>mpe</code>.</p>
</section><section id="msd" class="level3" data-number="4.1.8"><h3 data-number="4.1.8" class="anchored" data-anchor-id="msd">
<span class="header-section-number">4.1.8</span> MSD</h3>
<p>Średnia znakowa różnic (ang. <em>Mean Signed Deviation</em>), znana również jako średnie odchylenie znakowe i średni błąd znakowy, jest statystyką próbkową, która podsumowuje, jak dobrze szacunki <span class="math inline">\(\hat{Y}\)</span> pasują do wielkości obserwowanych <span class="math inline">\(Y\)</span>. Definiujemy ją następująco:</p>
<p><span id="eq-msd"><span class="math display">\[
MSD = \frac{1}{n}\sum_{i=1}^n(\hat{y}_i-y_i).
\tag{4.8}\]</span></span></p>
<p>Interpretacja podobnie jak w przypadku innych błędów i mniej wynosi miara tym lepiej dopasowany model. Wywołujemy go funkcją <code>msd</code>.</p>
<p>Istnieje cały szereg miar specjalistycznych rzadziej stosowanych w zagadnieniach regresyjnych. Wśród nich należy wymienić</p>
</section><section id="funkcja-straty-hubera" class="level3" data-number="4.1.9"><h3 data-number="4.1.9" class="anchored" data-anchor-id="funkcja-straty-hubera">
<span class="header-section-number">4.1.9</span> Funkcja straty Hubera</h3>
<p>Funkcja straty Hubera (ang. <em>Huber loss</em>) jest miarą błędu nieco bardziej odporną na punkty odstające niż RMSE. Definiujemy ją następująco:</p>
<p><span id="eq-huber"><span class="math display">\[
L_{\delta}(y, \hat{y})= \begin{cases}
  \frac12 (y_i-\hat{y}_i)^2, &amp;\text{ jeśli }\vert y_i-\hat{y}_i\vert\leq\delta\\
  \delta\cdot \vert y_i-\hat{y}_i\vert-\tfrac12\delta, &amp;\text{ w przeciwnym przypadku}.
\end{cases}
\tag{4.9}\]</span></span></p>
<p>W implementacji <code>yardstick</code> <span class="math inline">\(\delta=1\)</span> natomiast wyliczanie funkcji straty następuje przez uśrednienie po wszystkich obserwacjach. Z definicji widać, że funkcja straty Hubera jest kombinacją MSE i odpowiednio przekształconej miary MAE, w zależności od tego czy predykcja znacząco odbiegają od obserwowanych wartości. Wywołujemy ją przez funkcję <code>huber_loss</code>.</p>
</section><section id="funkcja-straty-pseudo-hubera" class="level3 page-columns page-full" data-number="4.1.10"><h3 data-number="4.1.10" class="anchored" data-anchor-id="funkcja-straty-pseudo-hubera">
<span class="header-section-number">4.1.10</span> Funkcja straty Pseudo-Hubera</h3>
<div class="page-columns page-full"><p>Funkcja straty Pseudo-Hubera (ang. <em>Pseudo-Huber loss</em>) może być stosowana jako gładkie przybliżenie funkcji straty Hubera. Łączy ona najlepsze właściwości straty kwadratowej<a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a> i straty bezwzględnej<a href="#fn7" class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a>, będąc silnie wypukłą, gdy znajduje się blisko celu (minimum) i mniej stromą dla wartości ekstremalnych . Skala, przy której funkcja straty Pseudo-Hubera przechodzi od straty L2 dla wartości bliskich minimum do straty L1 może być kontrolowana przez parametr <span class="math inline">\(\delta\)</span>. Funkcja straty Pseudo-Hubera zapewnia, że pochodne są ciągłe dla wszystkich stopni . Definiujemy ją następująco :</p><div class="no-row-height column-margin column-container"><li id="fn6"><p><sup>6</sup>&nbsp;inaczej w normie L2</p></li><li id="fn7"><p><sup>7</sup>&nbsp;w normie L1</p></li></div></div>
<p><span id="eq-huber2"><span class="math display">\[
L_{\delta}(y-\hat{y})=\delta^2\left(\sqrt{1+((y-\hat{y})/\delta)^2}-1\right).
\tag{4.10}\]</span></span> Wywołujemy ją za pomocą funkcji <code>huber_loss_pseudo</code>.</p>
</section><section id="logarytm-funkcji-straty-dla-rozkładu-poissona" class="level3" data-number="4.1.11"><h3 data-number="4.1.11" class="anchored" data-anchor-id="logarytm-funkcji-straty-dla-rozkładu-poissona">
<span class="header-section-number">4.1.11</span> Logarytm funkcji straty dla rozkładu Poissona</h3>
<p>Logarytm funkcji straty dla rozkładu Poissona (ang. <em>Mean log-loss for Poisson data</em>) definiowany jest w następujący sposób:</p>
<p><span class="math display">\[
\mathcal{L}=\frac1n\sum_{i=11}^n(\hat{y}_i-y_i\cdot \ln(\hat{y}_i)).
\]</span></p>
<p>Wywołujemy go funkcją <code>poisson_log_los</code>.</p>
</section><section id="smape" class="level3" data-number="4.1.12"><h3 data-number="4.1.12" class="anchored" data-anchor-id="smape">
<span class="header-section-number">4.1.12</span> SMAPE</h3>
<p>Symetryczny średni bezwzględny błąd procentowy (ang. <em>Symmetric Mean Absolute Percentage Error</em>) jest miarą dokładności opartą na błędach procentowych (lub względnych). Definiujemy ją następująco:</p>
<p><span id="eq-smape"><span class="math display">\[
SMAPE = \frac1n\sum_{i=1}^n\frac{\vert y_i-\hat{y}_i\vert}{(|y_i|+|\hat{y}_i|)/2}\cdot100\%.
\tag{4.11}\]</span></span></p>
<p>Wywołujemy go funkcją <code>smape</code>.</p>
</section><section id="rpd" class="level3" data-number="4.1.13"><h3 data-number="4.1.13" class="anchored" data-anchor-id="rpd">
<span class="header-section-number">4.1.13</span> RPD</h3>
<p>Stosunek wydajności do odchylenia standardowego (ang. <em>Ratio of Performance to Deviation</em>) definiujemy jako</p>
<p><span id="eq-rpd"><span class="math display">\[
RPD = \frac{SD}{RMSE},
\tag{4.12}\]</span></span></p>
<p>gdzie <span class="math inline">\(SD\)</span> oczywiście oznacza odchylenie standardowe zmiennej zależnej. Tym razem interpretujemy go w ten sposób, że im wyższa jest wartość RPD tym lepiej dopasowany model. Wywołujemy za pomocą <code>rpd</code>.</p>
<p>W szczególności w dziedzinie spektroskopii, stosunek wydajności do odchylenia (RPD) został użyty jako standardowy sposób raportowania jakości modelu. Jest to stosunek odchylenia standardowego zmiennej do błędu standardowego przewidywania tej zmiennej przez dany model. Jednak jego systematyczne stosowanie zostało skrytykowane przez kilku autorów, ponieważ użycie odchylenia standardowego do reprezentowania rozrzutu zmiennej może być niewłaściwe w przypadku zbiorów danych z asymetrią rozkładów. Stosunek wydajności do rozstępu międzykwartylowego został wprowadzony przez <span class="citation" data-cites="bellon-maurelCriticalReviewChemometric2010">Bellon-Maurel i in. (<a href="references.html#ref-bellon-maurelCriticalReviewChemometric2010" role="doc-biblioref">2010</a>)</span> w celu rozwiązania niektórych z tych problemów i uogólnienia RPD na zmienne o rozkładzie nienormalnym.</p>
</section><section id="rpiq" class="level3" data-number="4.1.14"><h3 data-number="4.1.14" class="anchored" data-anchor-id="rpiq">
<span class="header-section-number">4.1.14</span> RPIQ</h3>
<p>Stosunek wartości do rozstępu międzykwartylowego (ang. <em>Ratio of Performance to Inter-Quartile</em>) definiujemy następująco:</p>
<p><span id="eq-rpiq"><span class="math display">\[
RPIQ = \frac{IQ}{RMSE},
\tag{4.13}\]</span></span></p>
<p>gdzie <span class="math inline">\(IQ\)</span> oznacza rozstęp kwartylowy zmiennej zależnej. Wywołujemy go przez funkcję <code>rpiq.</code></p>
</section><section id="ccc" class="level3" data-number="4.1.15"><h3 data-number="4.1.15" class="anchored" data-anchor-id="ccc">
<span class="header-section-number">4.1.15</span> CCC</h3>
<p>Korelacyjny współczynnik zgodności (ang. <em>Concordance Correlation Coefficient</em>) mierzy zgodność pomiędzy wartościami predykcji i obserwowanymi. Definiujemy go w następujący sposób:</p>
<p><span class="math display">\[
CCC = \frac{2\rho\sigma_y\sigma_{\hat{y}}}{\sigma^2_{y}+\sigma^2_{\hat{y}}+(\mu_y-\mu_{\hat{y}})^2},
\]</span></p>
<p>gdzie <span class="math inline">\(\mu_y,\mu_{\hat{y}}\)</span> oznaczają średnią wartości obserwowanych i przewidywanych odpowiednio, <span class="math inline">\(\sigma_{y},\sigma_{\hat{y}}\)</span> stanowią natomiast odchylenia standardowe tych wielkości. <span class="math inline">\(\rho\)</span> jest współczynnikiem korelacji pomiędzy <span class="math inline">\(Y\)</span> i <span class="math inline">\(\hat{Y}\)</span>. Wywołanie w R to funkcja <code>ccc</code>.</p>
</section><section id="podsumowanie-miar-dla-modeli-regresyjnych" class="level3 page-columns page-full" data-number="4.1.16"><h3 data-number="4.1.16" class="anchored" data-anchor-id="podsumowanie-miar-dla-modeli-regresyjnych">
<span class="header-section-number">4.1.16</span> Podsumowanie miar dla modeli regresyjnych</h3>
<p>Wśród miar dopasowania modelu można wyróżnić, te które mierzą zgodność pomiędzy wartościami obserwowanymi a przewidywanymi, wyrażone często pewnego rodzaju korelacjami (lub ich kwadratami), a interpretujemy je w ten sposób, że im wyższe wartości tych współczynników tym bardziej zgodne są predykcje z obserwacjami. Drugą duża grupę miar stanowią błędy (bezwzględne i względne), które mierzą w różny sposób różnice pomiędzy wartościami obserwowanymi i przewidywanymi. Jedne są bardziej odporne wartości odstające inne mniej, a wszystkie interpretujemy tak, że jeśli ich wartość jest mniejsza tym lepiej jest dopasowany model.</p>
<div id="exm-1" class="theorem example">
<p><span class="theorem-title"><strong>Przykład 4.1 </strong></span>Dla zilustrowania działania wspomnianych miar przeanalizujemy przykład modelu regresyjnego. Dla przykładu rozwiążemy zadanie przewidywania wytrzymałości betonu na podstawie jego parametrów. Do tego celu użyjemy danych ze zbioru <code>concrete</code> pakietu <code>modeldata</code>.<span class="citation" data-cites="yehAnalysisStrengthConcrete2006">(<a href="references.html#ref-yehAnalysisStrengthConcrete2006" role="doc-biblioref">Yeh 2006</a>)</span></p>
<div class="cell">
<details open=""><summary>Kod</summary><div class="sourceCode" id="cb1"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://tidymodels.tidymodels.org">tidymodels</a></span><span class="op">)</span></span>
<span></span>
<span><span class="co"># charakterystyka danych</span></span>
<span><span class="fu">glimpse</span><span class="op">(</span><span class="va">concrete</span><span class="op">)</span></span></code><button title="Kopiuj do schowka" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output cell-output-stdout">
<pre><code>Rows: 1,030
Columns: 9
$ cement               &lt;dbl&gt; 540.0, 540.0, 332.5, 332.5, 198.6, 266.0, 380.0, …
$ blast_furnace_slag   &lt;dbl&gt; 0.0, 0.0, 142.5, 142.5, 132.4, 114.0, 95.0, 95.0,…
$ fly_ash              &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0…
$ water                &lt;dbl&gt; 162, 162, 228, 228, 192, 228, 228, 228, 228, 228,…
$ superplasticizer     &lt;dbl&gt; 2.5, 2.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,…
$ coarse_aggregate     &lt;dbl&gt; 1040.0, 1055.0, 932.0, 932.0, 978.4, 932.0, 932.0…
$ fine_aggregate       &lt;dbl&gt; 676.0, 676.0, 594.0, 594.0, 825.5, 670.0, 594.0, …
$ age                  &lt;int&gt; 28, 28, 270, 365, 360, 90, 365, 28, 28, 28, 90, 2…
$ compressive_strength &lt;dbl&gt; 79.99, 61.89, 40.27, 41.05, 44.30, 47.03, 43.70, …</code></pre>
</div>
<details open=""><summary>Kod</summary><div class="sourceCode" id="cb3"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="co"># modelowania dokonamy bez szczególnego uwzględnienia charakteru zmiennych,</span></span>
<span><span class="co"># tuningowania i innych czynności, które będą nam towarzyszyć w normalnej</span></span>
<span><span class="co"># budowie modelu</span></span>
<span></span>
<span><span class="co"># podział danych na uczące i testowe</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/Random.html">set.seed</a></span><span class="op">(</span><span class="fl">44</span><span class="op">)</span></span>
<span><span class="va">split</span> <span class="op">&lt;-</span> <span class="fu">initial_split</span><span class="op">(</span>data <span class="op">=</span> <span class="va">concrete</span>,</span>
<span>                       prop <span class="op">=</span> <span class="fl">0.7</span><span class="op">)</span></span>
<span><span class="va">train_data</span> <span class="op">&lt;-</span> <span class="fu">training</span><span class="op">(</span><span class="va">split</span><span class="op">)</span></span>
<span><span class="va">test_data</span> <span class="op">&lt;-</span> <span class="fu">testing</span><span class="op">(</span><span class="va">split</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># określenie modeli, wybrałem kNN</span></span>
<span><span class="va">knn5</span> <span class="op">&lt;-</span></span>
<span>  <span class="fu">nearest_neighbor</span><span class="op">(</span>neighbors <span class="op">=</span> <span class="fl">5</span><span class="op">)</span> <span class="op">|&gt;</span> </span>
<span>  <span class="fu">set_engine</span><span class="op">(</span><span class="st">'kknn'</span><span class="op">)</span> <span class="op">%&gt;%</span></span>
<span>  <span class="fu">set_mode</span><span class="op">(</span><span class="st">'regression'</span><span class="op">)</span></span>
<span></span>
<span><span class="va">knn25</span> <span class="op">&lt;-</span></span>
<span>  <span class="fu">nearest_neighbor</span><span class="op">(</span>neighbors <span class="op">=</span> <span class="fl">25</span><span class="op">)</span> <span class="op">|&gt;</span> </span>
<span>  <span class="fu">set_engine</span><span class="op">(</span><span class="st">'kknn'</span><span class="op">)</span> <span class="op">%&gt;%</span></span>
<span>  <span class="fu">set_mode</span><span class="op">(</span><span class="st">'regression'</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># uczymy modele</span></span>
<span><span class="va">fit5</span> <span class="op">&lt;-</span> <span class="va">knn5</span> <span class="op">|&gt;</span> </span>
<span>  <span class="fu">fit</span><span class="op">(</span><span class="va">compressive_strength</span><span class="op">~</span><span class="va">.</span>, data <span class="op">=</span> <span class="va">train_data</span><span class="op">)</span></span>
<span></span>
<span><span class="va">fit25</span> <span class="op">&lt;-</span> <span class="va">knn25</span> <span class="op">|&gt;</span> </span>
<span>  <span class="fu">fit</span><span class="op">(</span><span class="va">compressive_strength</span><span class="op">~</span><span class="va">.</span>, data <span class="op">=</span> <span class="va">train_data</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># obliczamy predykcję dla obu modeli na obu zbiorach</span></span>
<span><span class="va">pred_train5</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/predict.html">predict</a></span><span class="op">(</span><span class="va">fit5</span>, <span class="va">train_data</span><span class="op">)</span></span>
<span><span class="va">pred_train25</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/predict.html">predict</a></span><span class="op">(</span><span class="va">fit25</span>, <span class="va">train_data</span><span class="op">)</span></span>
<span><span class="va">pred_test5</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/predict.html">predict</a></span><span class="op">(</span><span class="va">fit5</span>, <span class="va">test_data</span><span class="op">)</span></span>
<span><span class="va">pred_test25</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/predict.html">predict</a></span><span class="op">(</span><span class="va">fit25</span>, <span class="va">test_data</span><span class="op">)</span></span></code><button title="Kopiuj do schowka" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div class="cell">
<details open=""><summary>Kod</summary><div class="sourceCode" id="cb4"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu">bind_cols</span><span class="op">(</span>obs <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="va">train_data</span><span class="op">$</span><span class="va">compressive_strength</span>, <span class="va">test_data</span><span class="op">$</span><span class="va">compressive_strength</span><span class="op">)</span>,</span>
<span>          pred5 <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="va">pred_train5</span><span class="op">$</span><span class="va">.pred</span>, <span class="va">pred_test5</span><span class="op">$</span><span class="va">.pred</span><span class="op">)</span>,</span>
<span>          pred25 <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="va">pred_train25</span><span class="op">$</span><span class="va">.pred</span>, <span class="va">pred_test25</span><span class="op">$</span><span class="va">.pred</span><span class="op">)</span><span class="op">)</span> <span class="op">|&gt;</span> </span>
<span>  <span class="fu">mutate</span><span class="op">(</span>sample <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html">rep</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"train"</span>, <span class="st">"test"</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/nrow.html">nrow</a></span><span class="op">(</span><span class="va">train_data</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/nrow.html">nrow</a></span><span class="op">(</span><span class="va">test_data</span><span class="op">)</span><span class="op">)</span><span class="op">)</span><span class="op">)</span> <span class="op">|&gt;</span> </span>
<span>  <span class="fu">pivot_longer</span><span class="op">(</span>cols <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="va">pred5</span>, <span class="va">pred25</span><span class="op">)</span>,</span>
<span>               names_to <span class="op">=</span> <span class="st">"model"</span>,</span>
<span>               values_to <span class="op">=</span> <span class="st">"pred"</span><span class="op">)</span> <span class="op">|&gt;</span> </span>
<span>  <span class="fu">mutate</span><span class="op">(</span>model <span class="op">=</span> <span class="fu">case_when</span><span class="op">(</span></span>
<span>    <span class="va">model</span> <span class="op">==</span> <span class="st">"pred5"</span> <span class="op">~</span> <span class="st">"knn5"</span>,</span>
<span>    <span class="va">model</span> <span class="op">==</span> <span class="st">"pred25"</span> <span class="op">~</span> <span class="st">"knn25"</span></span>
<span>  <span class="op">)</span><span class="op">)</span> <span class="op">|&gt;</span> </span>
<span>  <span class="fu">ggplot</span><span class="op">(</span><span class="fu">aes</span><span class="op">(</span>x <span class="op">=</span> <span class="va">obs</span>, y <span class="op">=</span> <span class="va">pred</span><span class="op">)</span><span class="op">)</span><span class="op">+</span></span>
<span>  <span class="fu">geom_point</span><span class="op">(</span>alpha <span class="op">=</span> <span class="fl">0.1</span><span class="op">)</span><span class="op">+</span></span>
<span>  <span class="fu">geom_abline</span><span class="op">(</span>intercept <span class="op">=</span> <span class="fl">0</span>, </span>
<span>              slope <span class="op">=</span> <span class="fl">1</span><span class="op">)</span><span class="op">+</span></span>
<span>  <span class="fu">facet_grid</span><span class="op">(</span><span class="va">sample</span><span class="op">~</span><span class="va">model</span><span class="op">)</span><span class="op">+</span></span>
<span>  <span class="fu">coord_obs_pred</span><span class="op">(</span><span class="op">)</span></span></code><button title="Kopiuj do schowka" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output-display">
<div id="fig-por1" class="quarto-figure quarto-figure-center anchored">
<figure class="figure"><p><img src="measures_files/figure-html/fig-por1-1.png" class="img-fluid figure-img" width="672"></p>
<p></p><figcaption class="figure-caption">Rysunek&nbsp;4.1: Graficzne porównanie obu modeli na obu zbiorach</figcaption><p></p>
</figure>
</div>
</div>
</div>
<div class="cell">
<details open=""><summary>Kod</summary><div class="sourceCode" id="cb5"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="co"># podsumowanie za pomocą miary R2</span></span>
<span><span class="fu">bind_cols</span><span class="op">(</span>obs <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="va">train_data</span><span class="op">$</span><span class="va">compressive_strength</span>, <span class="va">test_data</span><span class="op">$</span><span class="va">compressive_strength</span><span class="op">)</span>,</span>
<span>          pred5 <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="va">pred_train5</span><span class="op">$</span><span class="va">.pred</span>, <span class="va">pred_test5</span><span class="op">$</span><span class="va">.pred</span><span class="op">)</span>,</span>
<span>          pred25 <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="va">pred_train25</span><span class="op">$</span><span class="va">.pred</span>, <span class="va">pred_test25</span><span class="op">$</span><span class="va">.pred</span><span class="op">)</span><span class="op">)</span> <span class="op">|&gt;</span> </span>
<span>  <span class="fu">mutate</span><span class="op">(</span>sample <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html">rep</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"train"</span>, <span class="st">"test"</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/nrow.html">nrow</a></span><span class="op">(</span><span class="va">train_data</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/nrow.html">nrow</a></span><span class="op">(</span><span class="va">test_data</span><span class="op">)</span><span class="op">)</span><span class="op">)</span><span class="op">)</span> <span class="op">|&gt;</span> </span>
<span>  <span class="fu">pivot_longer</span><span class="op">(</span>cols <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="va">pred5</span>, <span class="va">pred25</span><span class="op">)</span>,</span>
<span>               names_to <span class="op">=</span> <span class="st">"model"</span>,</span>
<span>               values_to <span class="op">=</span> <span class="st">"pred"</span><span class="op">)</span> <span class="op">|&gt;</span> </span>
<span>  <span class="fu">group_by</span><span class="op">(</span><span class="va">model</span>, <span class="va">sample</span><span class="op">)</span> <span class="op">|&gt;</span> </span>
<span>  <span class="fu">rsq</span><span class="op">(</span>truth <span class="op">=</span> <span class="va">obs</span>, estimate <span class="op">=</span> <span class="va">pred</span><span class="op">)</span> <span class="op">|&gt;</span> </span>
<span>  <span class="fu">arrange</span><span class="op">(</span><span class="va">model</span><span class="op">)</span></span></code><button title="Kopiuj do schowka" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output cell-output-stdout">
<pre><code># A tibble: 4 × 5
  model  sample .metric .estimator .estimate
  &lt;chr&gt;  &lt;chr&gt;  &lt;chr&gt;   &lt;chr&gt;          &lt;dbl&gt;
1 pred25 test   rsq     standard       0.645
2 pred25 train  rsq     standard       0.787
3 pred5  test   rsq     standard       0.737
4 pred5  train  rsq     standard       0.929</code></pre>
</div>
<details open=""><summary>Kod</summary><div class="sourceCode" id="cb7"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="co"># można też podsumować od razu kilkoma miarami</span></span>
<span><span class="co"># będa miary domyślne dla modelu regresyjnego</span></span>
<span><span class="fu">bind_cols</span><span class="op">(</span>obs <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="va">train_data</span><span class="op">$</span><span class="va">compressive_strength</span>, <span class="va">test_data</span><span class="op">$</span><span class="va">compressive_strength</span><span class="op">)</span>,</span>
<span>          pred5 <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="va">pred_train5</span><span class="op">$</span><span class="va">.pred</span>, <span class="va">pred_test5</span><span class="op">$</span><span class="va">.pred</span><span class="op">)</span>,</span>
<span>          pred25 <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="va">pred_train25</span><span class="op">$</span><span class="va">.pred</span>, <span class="va">pred_test25</span><span class="op">$</span><span class="va">.pred</span><span class="op">)</span><span class="op">)</span> <span class="op">|&gt;</span> </span>
<span>  <span class="fu">mutate</span><span class="op">(</span>sample <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html">rep</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"train"</span>, <span class="st">"test"</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/nrow.html">nrow</a></span><span class="op">(</span><span class="va">train_data</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/nrow.html">nrow</a></span><span class="op">(</span><span class="va">test_data</span><span class="op">)</span><span class="op">)</span><span class="op">)</span><span class="op">)</span> <span class="op">|&gt;</span> </span>
<span>  <span class="fu">pivot_longer</span><span class="op">(</span>cols <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="va">pred5</span>, <span class="va">pred25</span><span class="op">)</span>,</span>
<span>               names_to <span class="op">=</span> <span class="st">"model"</span>,</span>
<span>               values_to <span class="op">=</span> <span class="st">"pred"</span><span class="op">)</span> <span class="op">|&gt;</span> </span>
<span>  <span class="fu">group_by</span><span class="op">(</span><span class="va">model</span>, <span class="va">sample</span><span class="op">)</span> <span class="op">|&gt;</span> </span>
<span>  <span class="fu">metrics</span><span class="op">(</span>truth <span class="op">=</span> <span class="va">obs</span>, estimate <span class="op">=</span> <span class="va">pred</span><span class="op">)</span> <span class="op">|&gt;</span> </span>
<span>  <span class="fu">arrange</span><span class="op">(</span><span class="va">model</span>, <span class="va">.metric</span><span class="op">)</span></span></code><button title="Kopiuj do schowka" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output cell-output-stdout">
<pre><code># A tibble: 12 × 5
   model  sample .metric .estimator .estimate
   &lt;chr&gt;  &lt;chr&gt;  &lt;chr&gt;   &lt;chr&gt;          &lt;dbl&gt;
 1 pred25 test   mae     standard       7.73 
 2 pred25 train  mae     standard       6.50 
 3 pred25 test   rmse    standard       9.74 
 4 pred25 train  rmse    standard       8.22 
 5 pred25 test   rsq     standard       0.645
 6 pred25 train  rsq     standard       0.787
 7 pred5  test   mae     standard       6.33 
 8 pred5  train  mae     standard       3.45 
 9 pred5  test   rmse    standard       8.26 
10 pred5  train  rmse    standard       4.68 
11 pred5  test   rsq     standard       0.737
12 pred5  train  rsq     standard       0.929</code></pre>
</div>
<details open=""><summary>Kod</summary><div class="sourceCode" id="cb9"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="co"># możemy zmienić parametry niektórych miar</span></span>
<span><span class="va">huber_loss2</span> <span class="op">&lt;-</span> <span class="fu">metric_tweak</span><span class="op">(</span><span class="st">"huber_loss2"</span>, <span class="va">huber_loss</span>, delta <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># można również wybrać jakie miary zostana użyte</span></span>
<span><span class="va">selected_metrics</span> <span class="op">&lt;-</span> <span class="fu">metric_set</span><span class="op">(</span><span class="va">ccc</span>, <span class="va">rpd</span>, <span class="va">mape</span>, <span class="va">huber_loss2</span><span class="op">)</span></span>
<span></span>
<span></span>
<span><span class="fu">bind_cols</span><span class="op">(</span>obs <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="va">train_data</span><span class="op">$</span><span class="va">compressive_strength</span>, <span class="va">test_data</span><span class="op">$</span><span class="va">compressive_strength</span><span class="op">)</span>,</span>
<span>          pred5 <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="va">pred_train5</span><span class="op">$</span><span class="va">.pred</span>, <span class="va">pred_test5</span><span class="op">$</span><span class="va">.pred</span><span class="op">)</span>,</span>
<span>          pred25 <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="va">pred_train25</span><span class="op">$</span><span class="va">.pred</span>, <span class="va">pred_test25</span><span class="op">$</span><span class="va">.pred</span><span class="op">)</span><span class="op">)</span> <span class="op">|&gt;</span> </span>
<span>  <span class="fu">mutate</span><span class="op">(</span>sample <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html">rep</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"train"</span>, <span class="st">"test"</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/nrow.html">nrow</a></span><span class="op">(</span><span class="va">train_data</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/nrow.html">nrow</a></span><span class="op">(</span><span class="va">test_data</span><span class="op">)</span><span class="op">)</span><span class="op">)</span><span class="op">)</span> <span class="op">|&gt;</span> </span>
<span>  <span class="fu">pivot_longer</span><span class="op">(</span>cols <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="va">pred5</span>, <span class="va">pred25</span><span class="op">)</span>,</span>
<span>               names_to <span class="op">=</span> <span class="st">"model"</span>,</span>
<span>               values_to <span class="op">=</span> <span class="st">"pred"</span><span class="op">)</span> <span class="op">|&gt;</span> </span>
<span>  <span class="fu">group_by</span><span class="op">(</span><span class="va">model</span>, <span class="va">sample</span><span class="op">)</span> <span class="op">|&gt;</span> </span>
<span>  <span class="fu">selected_metrics</span><span class="op">(</span>truth <span class="op">=</span> <span class="va">obs</span>, estimate <span class="op">=</span> <span class="va">pred</span><span class="op">)</span> <span class="op">|&gt;</span> </span>
<span>  <span class="fu">arrange</span><span class="op">(</span><span class="va">model</span>, <span class="va">sample</span><span class="op">)</span></span></code><button title="Kopiuj do schowka" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output cell-output-stdout">
<pre><code># A tibble: 16 × 5
   model  sample .metric     .estimator .estimate
   &lt;chr&gt;  &lt;chr&gt;  &lt;chr&gt;       &lt;chr&gt;          &lt;dbl&gt;
 1 pred25 test   ccc         standard       0.750
 2 pred25 test   rpd         standard       1.64 
 3 pred25 test   mape        standard      30.9  
 4 pred25 test   huber_loss2 standard      13.6  
 5 pred25 train  ccc         standard       0.851
 6 pred25 train  rpd         standard       2.07 
 7 pred25 train  mape        standard      24.8  
 8 pred25 train  huber_loss2 standard      11.1  
 9 pred5  test   ccc         standard       0.844
10 pred5  test   rpd         standard       1.93 
11 pred5  test   mape        standard      24.1  
12 pred5  test   huber_loss2 standard      10.8  
13 pred5  train  ccc         standard       0.958
14 pred5  train  rpd         standard       3.64 
15 pred5  train  mape        standard      12.8  
16 pred5  train  huber_loss2 standard       5.19 </code></pre>
</div>
</div>
</div>
<div class="page-columns page-full"><p>W przypadku gdybyśmy chcieli zdefiniować własną miarę, to oczywiście jest taka możliwość<a href="#fn8" class="footnote-ref" id="fnref8" role="doc-noteref"><sup>8</sup></a> polecam stronę pakietu <code>yardstick</code> - <a href="https://www.tidymodels.org/learn/develop/metrics/" class="uri">https://www.tidymodels.org/learn/develop/metrics/</a>.</p><div class="no-row-height column-margin column-container"><li id="fn8"><p><sup>8</sup>&nbsp;choć liczba już istniejących jest imponująca</p></li></div></div>
</section></section><section id="miary-dopasowania-modeli-klasyfikacyjnych" class="level2" data-number="4.2"><h2 data-number="4.2" class="anchored" data-anchor-id="miary-dopasowania-modeli-klasyfikacyjnych">
<span class="header-section-number">4.2</span> Miary dopasowania modeli klasyfikacyjnych</h2>
<p>Jak to zostało wspomniane wcześniej w modelach klasyfikacyjnych można podzielić miary dopasowania na te, które dotyczą modeli z binarną zmienną wynikową i ze zmienna wielostanową. Miary można też podzielić na te, które zależą od prawdopodobieństwa poszczególnych stanów i te, które zależą tylko od klasyfikacji wynikowej.</p>
<p>Do wyliczenia miar probabilistycznych konieczne jest wyliczenie predykcji z prawdopodobieństwami poszczególnych stanów. Aby uzyskać taki efekt wystarczy w predykcji modelu użyć parametru <code>type = "prob"</code>. W przykładzie podsumowującym miary będzie to zilustrowane.</p>
<p>Na to, aby przybliżyć miary dopasowania opartych o prawdopodobieństwa stanów, konieczne jest wprowadzenie pojęcia macierzy klasyfikacji (ang. <em>confusion matrix</em>). Można je stosować zarówno do klasyfikacji dwustanowej, jak i wielostanowej. Użyjemy przykładu binarnego aby zilustrować szczegóły tej macierzy.</p>
<div class="cell">
<details open=""><summary>Kod</summary><div class="sourceCode" id="cb11"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="co"># import danych do przykładu</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/data.html">data</a></span><span class="op">(</span><span class="va">two_class_example</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># kilka pierwszych wierszy wyników predykcji</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/head.html">head</a></span><span class="op">(</span><span class="va">two_class_example</span><span class="op">)</span></span></code><button title="Kopiuj do schowka" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output cell-output-stdout">
<pre><code>   truth      Class1       Class2 predicted
1 Class2 0.003589243 0.9964107574    Class2
2 Class1 0.678621054 0.3213789460    Class1
3 Class2 0.110893522 0.8891064779    Class2
4 Class1 0.735161703 0.2648382969    Class1
5 Class2 0.016239960 0.9837600397    Class2
6 Class1 0.999275071 0.0007249286    Class1</code></pre>
</div>
<details open=""><summary>Kod</summary><div class="sourceCode" id="cb13"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="co"># confusion matrix</span></span>
<span><span class="va">two_class_example</span> <span class="op">|&gt;</span> </span>
<span>  <span class="fu">conf_mat</span><span class="op">(</span><span class="va">truth</span>, <span class="va">predicted</span><span class="op">)</span> <span class="op">|&gt;</span> </span>
<span>  <span class="fu">autoplot</span><span class="op">(</span>type <span class="op">=</span> <span class="st">"heatmap"</span><span class="op">)</span></span></code><button title="Kopiuj do schowka" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output-display">
<div id="fig-confmat" class="quarto-figure quarto-figure-center anchored">
<figure class="figure"><p><img src="measures_files/figure-html/fig-confmat-1.png" class="img-fluid figure-img" width="672"></p>
<p></p><figcaption class="figure-caption">Rysunek&nbsp;4.2: Przykładowa macierz klasyfikacji</figcaption><p></p>
</figure>
</div>
</div>
</div>
<p>Aby przedstawić poszczególne miary na podstawie macierzy klasyfikacji wystarczy przywołać ilustrację z <a href="https://en.wikipedia.org/wiki/Confusion_matrix">Wikipedii</a>, która w genialny sposób podsumowuje większość miar.</p>
<div id="fig-confmat2" class="quarto-figure quarto-figure-center anchored">
<figure class="figure"><p><img src="images/Zrzut ekranu 2023-02-14 o 17.21.10.png" class="img-fluid figure-img"></p>
<p></p><figcaption class="figure-caption">Rysunek&nbsp;4.3: Macierz klasyfikacji</figcaption><p></p>
</figure>
</div>
<p>Na podstawie tej macierzy możemy ocenić dopasowanie modelu za pomocą:</p>
<ul>
<li><p><em>accuacy</em> - informuje o odsetku poprawnie zaklasyfikowanych obserwacji. Jest bardzo powszechnie stosowaną miarą dopasowania modelu choć ma jedną poważną wadę. Mianowicie w przypadku modeli dla danych z wyraźną dysproporcją jednej z klas (powiedzmy jedna stanowi 95% wszystkich obserwacji), może się zdarzyć sytuacja, że nawet bezsensowny model, czyli taki, który zawsze wskazuje tą właśnie wartość, będzie miał <em>accuracy</em> na poziomie 95%.</p></li>
<li><p><em>kappa -</em> miara podobna miarą do <em>accuracy</em> i jest bardzo przydatna, gdy jedna lub więcej klas dominuje. Definiujemy ją następująco <span class="math inline">\(\kappa = \frac{p_o-p_e}{1-p_e}\)</span>, gdzie <span class="math inline">\(p_o,p_e\)</span> są odpowiednio zgodnością obserwowaną i oczekiwaną. Zgodność obserwowana jest odsetkiem obserwacji poprawnie zaklasyfikowanych, a oczekiwana to zgodność wynikająca z przypadku.</p></li>
<li><p><em>precision</em> - oznaczana też czasem jako PPV (ang. <em>Positive Predictive Value</em>) oznacza stosunek poprawnie zaklasyfikowanych wartości <em>true positive</em> (TP) do wszystkich przewidywanych wartości pozytywnych (ang. <em>positive predictive</em>).</p></li>
<li><p><em>recall -</em> nazywany także <em>sensitivity</em> lub <em>True Positive Rate</em> (TPR), który stanowi stosunek <em>true positive</em> do wszystkich przypadków <em>positive</em>.</p></li>
<li><p><em>specificity</em> - nazywane również <em>True Negative Rate</em> (TNR), wyraża się stosunkiem pozycji <em>true negative</em> do wszystkich obserwacji <em>negative</em>.</p></li>
<li><p><em>negative predictive value</em> (NPV) - oznaczane czasem też jako <em>false omission rate</em> jest liczone jako stosunek <em>false negative</em> do wszystkich przewidywanych <em>negative</em> (PN).</p></li>
<li><p><span class="math inline">\(F_1\)</span> - jest miarą zdefiniowaną jako <span class="math inline">\(\frac{2PPV*TPR}{PPV+TPR}\)</span>.</p></li>
<li><p>MCC - <em>Mathews Correlation Coeficient -</em> jest zdefiniowany jako <span class="math inline">\(\sqrt{TPR*TNR*PPV*NPV}-\sqrt{FNR*FPR*NPV*FDR}\)</span>. Istnieje również odmiana tej miary dla przypadku wielostanowej zmiennej wynikowej.</p></li>
<li><p><em>balanced accuracy</em> - liczona jako średnia <em>sensitivity</em> i <em>specificity</em>.</p></li>
<li><p><em>detection prevalence</em> - zdefiniowana jako stosunek poprawnie przewidywanych obserwacji do liczby wszystkich przewidywanych wartości.</p></li>
<li><p><em>J index</em> - metryka Youden’a definiowana jako <em>sensitivity + specificity -1</em>, często jest wykorzystywana do określenia poziomu odcięcia prawdopodobieństwa zdarzenia wyróżnionego (ang. <em>threshold</em>).</p></li>
<li><p>koszt niepoprawnej klasyfikacji - czasami niektóre błędy klasyfikacji są mniej kosztowne z punktu widzenie badacza, a inne bardziej. Wówczas można przypisać koszty błędnych klasyfikacji do poszczególnych klas, nakładając kary za błędne przypisane do innej klasy i w ten sposób zapobiegać takim sytuacjom.</p></li>
<li>
<p>średnia logarytmu funkcji straty (ang. <em>log loss</em>) - określana też w literaturze jako <em>binary cross-entropy</em> dla przypadku zmiennej wynikowej dwustanowej i <em>multilevel cross-entropy</em> albo <em>categorical cross-entropy</em> w przypadku wielostanowej klasyfikacji. Definiuje się ją następująco:</p>
<p><span id="eq-crossentropy"><span class="math display">\[
    \mathcal{L} = \frac1n\sum_{i=1}^n\left[y_i\log(\hat{y}_i)+(1-y_i)\log(1-\hat{y}_i)\right],
\tag{4.14}\]</span></span> gdzie <span class="math inline">\(y_i\)</span> jest indykatorem klasy wyróżnionej dla <span class="math inline">\(i\)</span>-tej obserwacji, a <span class="math inline">\(\hat{y}_i\)</span> prawdopodobieństwem wyróżnionego stanu <span class="math inline">\(i\)</span>-tej obserwacji. Piękną rzeczą w tej definicji jest to, że jest ona ściśle związana z teorią informacji: log-loss jest entropią krzyżową pomiędzy rozkładem prawdziwych etykiet a przewidywaniami i jest bardzo blisko związana z tym, co jest znane jako entropia względna lub rozbieżność Kullbacka-Leiblera. Entropia mierzy nieprzewidywalność czegoś. Entropia krzyżowa zawiera entropię prawdziwego rozkładu plus dodatkową nieprzewidywalność, gdy ktoś zakłada inny rozkład niż prawdziwy. Tak więc log-loss jest miarą z teorii informacji pozwalającą zmierzyć “dodatkowy szum”, który powstaje w wyniku użycia predykcji w przeciwieństwie do prawdziwych etykiet. Minimalizując entropię krzyżową, maksymalizujemy dokładność klasyfikatora. Log-loss, czyli strata logarytmiczna, wnika w najdrobniejsze szczegóły działania klasyfikatora.</p>
<p>Prawdopodobieństwo można rozumieć jako miernik zaufania. Jeśli prawdziwa etykieta to 0, ale klasyfikator ocenia, że należy ona do klasy 1 z prawdopodobieństwem 0,51, to pomimo tego, że klasyfikator popełniłby błąd, jest to niewielki błąd, ponieważ prawdopodobieństwo jest bardzo bliskie granicy decyzji 0,5. Log-loss jest subtelną miarą dokładności.</p>
</li>
</ul>
<p>Należy pamiętać, że większość wspomnianych miar opiera się na wartościach z macierzy klasyfikacji. Przy czym aby obserwacje zaklasyfikować do jednej z klas należy przyjąć pewien punkt odcięcia (<em>threshold</em>) prawdopodobieństwa, od którego przewidywana wartość będzie przyjmowała stan “1”. Domyślnie w wielu modelach ten punkt jest ustalony na poziomie 0,5. Nie jest on jednak optymalny ze względu na jakość klasyfikacji. Zmieniając ten próg otrzymamy różne wartości <em>specificity, sensitivity, precision, recall,</em> itd. Istnieją kryteria doboru progu odcięcia, np. oparte na wartości Youdena, F1, średniej geometrycznej itp. W przykładzie prezentowanym poniżej pokażemy zastosowanie dwóch z tych technik. Bez względu na przyjęty poziom odcięcia istnieją również miary i wykresy, które pozwalają zilustrować jakość modelu. Należą do nich:</p>
<ul>
<li>wykresy:
<ul>
<li><p>ROC - <em>Receiver Operating Characteristic -</em> krzywa, która przedstawia kompromis pomiędzy <em>sensitivity i specificity</em> dla różnych poziomów odcięcia. Ta egzotycznie brzmiąca nazwa wywodzi się z analizy sygnałów radiowych i została spopularyzowana w 1978 roku przez Charlesa Metza w artykule “Basic Principles of ROC Analysis”. Krzywa ROC pokazuje czułość klasyfikatora poprzez wykreślenie TPR do FPR. Innymi słowy, pokazuje ona, ile poprawnych pozytywnych klasyfikacji można uzyskać, gdy dopuszcza się coraz więcej fałszywych pozytywów. Idealny klasyfikator, który nie popełnia żadnych błędów, osiągnąłby natychmiast 100% wskaźnik prawdziwych pozytywów, bez żadnych fałszywych pozytywów - w praktyce prawie nigdy się to nie zdarza.</p></li>
<li><p>PRC - <em>Precision-Recall Curve</em> - krzywa, która pokazuje kompromis pomiędzy <em>precision i recall.</em> Precision i recall to tak naprawdę dwie metryki. Jednak często są one używane razem. Precision odpowiada na pytanie: “Z elementów, które klasyfikator przewidział jako pozytywnych ile jest rzeczywiście pozytywnych?”. Natomiast recall odpowiada na pytanie: “Spośród wszystkich elementów, które są pozytywne, ile zostało przewidzianych jako takie przez klasyfikator?”. Krzywa PRC to po prostu wykres z wartościami Precision na osi y i Recall na osi x. Innymi słowy, krzywa PRC zawiera TP/(TP+FP) na osi y oraz TP/(TP+FN) na osi x.</p></li>
<li><p>Krzywa wzrostu (ang. <em>Gain Curve</em>) - to krzywa przedstawiająca stosunek skumulowanej liczby pozytywnych (wyróżnionych) obserwacji w decylu do całkowitej liczby pozytywnych obserwacji w danych.</p></li>
<li><p>Krzywa wyniesienia (ang. <em>Lift Curve</em>) - jest stosunkiem liczby pozytywnych obserwacji w <span class="math inline">\(i\)</span>-tym decylu na podstawie modelu do oczekiwanej liczby pozytywnych obserwacji należących do <span class="math inline">\(i\)</span>-tego decyla na podstawie modelu losowego.</p></li>
</ul>
</li>
<li>miary:
<ul>
<li><p>AUC - <em>Area Under ROC Curve</em> - mierzy pole pod krzywą ROC. Krzywa ROC nie jest pojedynczą liczbą ale całą krzywą. Dostarcza ona szczegółowych informacji o zachowaniu klasyfikatora, ale trudno jest szybko porównać wiele krzywych ROC ze sobą. W szczególności, jeśli ktoś chciałby zastosować jakiś automatyczny mechanizm tuningowania hiperparametrów, maszyna potrzebowałaby wymiernego wyniku zamiast wykresu, który wymaga wizualnej inspekcji. AUC jest jednym ze sposobów podsumowania krzywej ROC w jedną liczbę, tak aby można było ją łatwo i automatycznie porównać. Dobra krzywa ROC ma dużo miejsca pod sobą (ponieważ prawdziwy wskaźnik pozytywny bardzo szybko wzrasta do 100%). Zła krzywa ROC obejmuje bardzo mały obszar. Tak więc wysokie AUC jest sygnałem dobrego dopasowania modelu.</p></li>
<li><p>PRAUC - <em>Area Under Precision-Racall Curve</em> - mierzy pole pod krzywą P-R.</p></li>
<li><p>Pole pod krzywą wzrosu.</p></li>
<li><p>Pole pod krzywą wyniesienia.</p></li>
</ul>
</li>
</ul>
<div id="exm-2" class="theorem example">
<p><span class="theorem-title"><strong>Przykład 4.2 </strong></span>Tym razem zbudujemy model klasyfikacyjny dla zmiennej wynikowej dwustanowej. Dane pochodzą ze zbioru <code>attrition</code> pakietu <code>modeldata</code>. Naszym zadaniem będzie zbudować modeli przewidujący odejścia z pracy.</p>
<div class="cell">
<details open=""><summary>Kod</summary><div class="sourceCode" id="cb14"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/utils/str.html">str</a></span><span class="op">(</span><span class="va">attrition</span><span class="op">)</span></span></code><button title="Kopiuj do schowka" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output cell-output-stdout">
<pre><code>'data.frame':   1470 obs. of  31 variables:
 $ Age                     : int  41 49 37 33 27 32 59 30 38 36 ...
 $ Attrition               : Factor w/ 2 levels "No","Yes": 2 1 2 1 1 1 1 1 1 1 ...
 $ BusinessTravel          : Factor w/ 3 levels "Non-Travel","Travel_Frequently",..: 3 2 3 2 3 2 3 3 2 3 ...
 $ DailyRate               : int  1102 279 1373 1392 591 1005 1324 1358 216 1299 ...
 $ Department              : Factor w/ 3 levels "Human_Resources",..: 3 2 2 2 2 2 2 2 2 2 ...
 $ DistanceFromHome        : int  1 8 2 3 2 2 3 24 23 27 ...
 $ Education               : Ord.factor w/ 5 levels "Below_College"&lt;..: 2 1 2 4 1 2 3 1 3 3 ...
 $ EducationField          : Factor w/ 6 levels "Human_Resources",..: 2 2 5 2 4 2 4 2 2 4 ...
 $ EnvironmentSatisfaction : Ord.factor w/ 4 levels "Low"&lt;"Medium"&lt;..: 2 3 4 4 1 4 3 4 4 3 ...
 $ Gender                  : Factor w/ 2 levels "Female","Male": 1 2 2 1 2 2 1 2 2 2 ...
 $ HourlyRate              : int  94 61 92 56 40 79 81 67 44 94 ...
 $ JobInvolvement          : Ord.factor w/ 4 levels "Low"&lt;"Medium"&lt;..: 3 2 2 3 3 3 4 3 2 3 ...
 $ JobLevel                : int  2 2 1 1 1 1 1 1 3 2 ...
 $ JobRole                 : Factor w/ 9 levels "Healthcare_Representative",..: 8 7 3 7 3 3 3 3 5 1 ...
 $ JobSatisfaction         : Ord.factor w/ 4 levels "Low"&lt;"Medium"&lt;..: 4 2 3 3 2 4 1 3 3 3 ...
 $ MaritalStatus           : Factor w/ 3 levels "Divorced","Married",..: 3 2 3 2 2 3 2 1 3 2 ...
 $ MonthlyIncome           : int  5993 5130 2090 2909 3468 3068 2670 2693 9526 5237 ...
 $ MonthlyRate             : int  19479 24907 2396 23159 16632 11864 9964 13335 8787 16577 ...
 $ NumCompaniesWorked      : int  8 1 6 1 9 0 4 1 0 6 ...
 $ OverTime                : Factor w/ 2 levels "No","Yes": 2 1 2 2 1 1 2 1 1 1 ...
 $ PercentSalaryHike       : int  11 23 15 11 12 13 20 22 21 13 ...
 $ PerformanceRating       : Ord.factor w/ 4 levels "Low"&lt;"Good"&lt;"Excellent"&lt;..: 3 4 3 3 3 3 4 4 4 3 ...
 $ RelationshipSatisfaction: Ord.factor w/ 4 levels "Low"&lt;"Medium"&lt;..: 1 4 2 3 4 3 1 2 2 2 ...
 $ StockOptionLevel        : int  0 1 0 0 1 0 3 1 0 2 ...
 $ TotalWorkingYears       : int  8 10 7 8 6 8 12 1 10 17 ...
 $ TrainingTimesLastYear   : int  0 3 3 3 3 2 3 2 2 3 ...
 $ WorkLifeBalance         : Ord.factor w/ 4 levels "Bad"&lt;"Good"&lt;"Better"&lt;..: 1 3 3 3 3 2 2 3 3 2 ...
 $ YearsAtCompany          : int  6 10 0 8 2 7 1 1 9 7 ...
 $ YearsInCurrentRole      : int  4 7 0 7 2 7 0 0 7 7 ...
 $ YearsSinceLastPromotion : int  0 1 0 3 2 3 0 0 1 7 ...
 $ YearsWithCurrManager    : int  5 7 0 0 2 6 0 0 8 7 ...</code></pre>
</div>
<details open=""><summary>Kod</summary><div class="sourceCode" id="cb16"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="co"># podział zbioru na uczący i testowy</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/Random.html">set.seed</a></span><span class="op">(</span><span class="fl">44</span><span class="op">)</span></span>
<span><span class="va">split</span> <span class="op">&lt;-</span> <span class="fu">initial_split</span><span class="op">(</span><span class="va">attrition</span>, prop <span class="op">=</span> <span class="fl">0.7</span>, strata <span class="op">=</span> <span class="st">"Attrition"</span><span class="op">)</span></span>
<span><span class="va">train_data</span> <span class="op">&lt;-</span> <span class="fu">training</span><span class="op">(</span><span class="va">split</span><span class="op">)</span></span>
<span><span class="va">test_data</span> <span class="op">&lt;-</span> <span class="fu">testing</span><span class="op">(</span><span class="va">split</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># określam model</span></span>
<span><span class="va">lr_mod</span> <span class="op">&lt;-</span> <span class="fu">logistic_reg</span><span class="op">(</span><span class="op">)</span> <span class="op">|&gt;</span> </span>
<span>  <span class="fu">set_engine</span><span class="op">(</span><span class="st">"glm"</span><span class="op">)</span> <span class="op">|&gt;</span> </span>
<span>  <span class="fu">set_mode</span><span class="op">(</span><span class="st">"classification"</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># uczę model</span></span>
<span><span class="va">lr_fit</span> <span class="op">&lt;-</span> <span class="va">lr_mod</span> <span class="op">|&gt;</span> </span>
<span>  <span class="fu">fit</span><span class="op">(</span><span class="va">Attrition</span> <span class="op">~</span> <span class="va">.</span>, data <span class="op">=</span> <span class="va">train_data</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># podsumowanie modelu</span></span>
<span><span class="va">lr_fit</span> <span class="op">|&gt;</span> </span>
<span>  <span class="fu">tidy</span><span class="op">(</span><span class="op">)</span> </span></code><button title="Kopiuj do schowka" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output cell-output-stdout">
<pre><code># A tibble: 58 × 5
   term                             estimate   std.error statistic   p.value
   &lt;chr&gt;                               &lt;dbl&gt;       &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;
 1 (Intercept)                     -3.41     1261.       -0.00270  0.998    
 2 Age                             -0.0375      0.0179   -2.09     0.0364   
 3 BusinessTravelTravel_Frequently  2.14        0.546     3.92     0.0000875
 4 BusinessTravelTravel_Rarely      1.31        0.505     2.60     0.00942  
 5 DailyRate                       -0.000213    0.000279 -0.766    0.444    
 6 DepartmentResearch_Development   0.783    1261.        0.000621 1.00     
 7 DepartmentSales                 13.7      1115.        0.0123   0.990    
 8 DistanceFromHome                 0.0452      0.0137    3.30     0.000964 
 9 Education.L                      0.353       0.435     0.811    0.417    
10 Education.Q                      0.170       0.372     0.458    0.647    
# ℹ 48 more rows</code></pre>
</div>
</div>
<p>Teraz korzystając z różnych miar podsumujemy dopasowanie modelu.</p>
<div class="cell">
<details open=""><summary>Kod</summary><div class="sourceCode" id="cb18"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="co"># predykcja z modelu przyjmując threshold = 0.5</span></span>
<span><span class="va">pred_class</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/predict.html">predict</a></span><span class="op">(</span><span class="va">lr_fit</span>, new_data <span class="op">=</span> <span class="va">test_data</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># predkcja (prawdopodobieństwa klas)</span></span>
<span><span class="va">pred_prob</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/predict.html">predict</a></span><span class="op">(</span><span class="va">lr_fit</span>, new_data <span class="op">=</span> <span class="va">test_data</span>, type <span class="op">=</span> <span class="st">"prob"</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># ale można też tak</span></span>
<span><span class="va">pred</span> <span class="op">&lt;-</span> <span class="fu">augment</span><span class="op">(</span><span class="va">lr_fit</span>, <span class="va">test_data</span><span class="op">)</span> <span class="op">|&gt;</span> </span>
<span>  <span class="fu">select</span><span class="op">(</span><span class="va">Attrition</span>, <span class="va">.pred_class</span>, <span class="va">.pred_No</span>, <span class="va">.pred_Yes</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># macierz klasyfikacji</span></span>
<span><span class="va">cm</span> <span class="op">&lt;-</span> <span class="va">pred</span> <span class="op">|&gt;</span> </span>
<span>  <span class="fu">conf_mat</span><span class="op">(</span>truth <span class="op">=</span> <span class="va">Attrition</span>, estimate <span class="op">=</span> <span class="va">.pred_class</span><span class="op">)</span></span>
<span><span class="va">cm</span></span></code><button title="Kopiuj do schowka" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output cell-output-stdout">
<pre><code>          Truth
Prediction  No Yes
       No  352  39
       Yes  18  33</code></pre>
</div>
<details open=""><summary>Kod</summary><div class="sourceCode" id="cb20"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/summary.html">summary</a></span><span class="op">(</span><span class="va">cm</span><span class="op">)</span></span></code><button title="Kopiuj do schowka" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output cell-output-stdout">
<pre><code># A tibble: 13 × 3
   .metric              .estimator .estimate
   &lt;chr&gt;                &lt;chr&gt;          &lt;dbl&gt;
 1 accuracy             binary         0.871
 2 kap                  binary         0.464
 3 sens                 binary         0.951
 4 spec                 binary         0.458
 5 ppv                  binary         0.900
 6 npv                  binary         0.647
 7 mcc                  binary         0.474
 8 j_index              binary         0.410
 9 bal_accuracy         binary         0.705
10 detection_prevalence binary         0.885
11 precision            binary         0.900
12 recall               binary         0.951
13 f_meas               binary         0.925</code></pre>
</div>
</div>
<p>Możemy też narysować krzywe, które nam pokażą, czy dla innych wartości progu model też dobrze przewiduje klasy wynikowe.</p>
<div class="cell">
<details open=""><summary>Kod</summary><div class="sourceCode" id="cb22"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="co">#ROC</span></span>
<span><span class="va">pred</span> <span class="op">|&gt;</span> </span>
<span>  <span class="fu">roc_curve</span><span class="op">(</span>truth <span class="op">=</span> <span class="va">Attrition</span>, <span class="va">.pred_Yes</span>, event_level <span class="op">=</span> <span class="st">"second"</span><span class="op">)</span> <span class="op">|&gt;</span> </span>
<span>  <span class="fu">autoplot</span><span class="op">(</span><span class="op">)</span></span></code><button title="Kopiuj do schowka" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output-display">
<p><img src="measures_files/figure-html/unnamed-chunk-7-1.png" class="img-fluid" width="672"></p>
</div>
<details open=""><summary>Kod</summary><div class="sourceCode" id="cb23"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="co">#PRC</span></span>
<span><span class="va">pred</span> <span class="op">|&gt;</span> </span>
<span>  <span class="fu">pr_curve</span><span class="op">(</span>truth <span class="op">=</span> <span class="va">Attrition</span>, <span class="va">.pred_Yes</span>, event_level <span class="op">=</span> <span class="st">"second"</span><span class="op">)</span> <span class="op">|&gt;</span> </span>
<span>  <span class="fu">autoplot</span><span class="op">(</span><span class="op">)</span></span></code><button title="Kopiuj do schowka" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output-display">
<p><img src="measures_files/figure-html/unnamed-chunk-7-2.png" class="img-fluid" width="672"></p>
</div>
<details open=""><summary>Kod</summary><div class="sourceCode" id="cb24"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="co">#AUC</span></span>
<span><span class="va">pred</span> <span class="op">|&gt;</span> </span>
<span>  <span class="fu">roc_auc</span><span class="op">(</span>truth <span class="op">=</span> <span class="va">Attrition</span>, <span class="va">.pred_Yes</span>, event_level <span class="op">=</span> <span class="st">"second"</span><span class="op">)</span> </span></code><button title="Kopiuj do schowka" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output cell-output-stdout">
<pre><code># A tibble: 1 × 3
  .metric .estimator .estimate
  &lt;chr&gt;   &lt;chr&gt;          &lt;dbl&gt;
1 roc_auc binary         0.808</code></pre>
</div>
<details open=""><summary>Kod</summary><div class="sourceCode" id="cb26"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="co">#PRAUC</span></span>
<span><span class="va">pred</span> <span class="op">|&gt;</span> </span>
<span>  <span class="fu">pr_auc</span><span class="op">(</span>truth <span class="op">=</span> <span class="va">Attrition</span>, <span class="va">.pred_Yes</span>, event_level <span class="op">=</span> <span class="st">"second"</span><span class="op">)</span> </span></code><button title="Kopiuj do schowka" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output cell-output-stdout">
<pre><code># A tibble: 1 × 3
  .metric .estimator .estimate
  &lt;chr&gt;   &lt;chr&gt;          &lt;dbl&gt;
1 pr_auc  binary         0.569</code></pre>
</div>
</div>
<p>Wybór optymalnego progu odcięcia.</p>
<div class="cell">
<details open=""><summary>Kod</summary><div class="sourceCode" id="cb28"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://github.com/tidymodels/probably/">probably</a></span><span class="op">)</span></span>
<span></span>
<span><span class="co"># ustalam zakres threshold</span></span>
<span><span class="va">thresholds</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.html">seq</a></span><span class="op">(</span><span class="fl">0.01</span>,<span class="fl">1</span>, by <span class="op">=</span> <span class="fl">0.01</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># poszukuje najlepszego progu ze względu kryterium Youden'a</span></span>
<span><span class="va">pred</span> <span class="op">|&gt;</span></span>
<span>  <span class="fu"><a href="https://probably.tidymodels.org/reference/threshold_perf.html">threshold_perf</a></span><span class="op">(</span><span class="va">Attrition</span>, <span class="va">.pred_Yes</span>, <span class="va">thresholds</span>, event_level <span class="op">=</span> <span class="st">"second"</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>  <span class="fu">pivot_wider</span><span class="op">(</span>names_from <span class="op">=</span> <span class="va">.metric</span>, values_from <span class="op">=</span> <span class="va">.estimate</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>  <span class="fu">arrange</span><span class="op">(</span><span class="op">-</span><span class="va">j_index</span><span class="op">)</span></span></code><button title="Kopiuj do schowka" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output cell-output-stdout">
<pre><code># A tibble: 100 × 6
   .threshold .estimator  sens  spec j_index distance
        &lt;dbl&gt; &lt;chr&gt;      &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt;    &lt;dbl&gt;
 1       0.19 binary     0.722 0.838   0.560    0.103
 2       0.17 binary     0.736 0.816   0.552    0.103
 3       0.18 binary     0.722 0.824   0.547    0.108
 4       0.16 binary     0.736 0.808   0.544    0.106
 5       0.2  binary     0.694 0.846   0.540    0.117
 6       0.22 binary     0.681 0.857   0.537    0.123
 7       0.15 binary     0.736 0.797   0.533    0.111
 8       0.21 binary     0.681 0.851   0.532    0.124
 9       0.12 binary     0.75  0.773   0.523    0.114
10       0.26 binary     0.639 0.884   0.523    0.144
# ℹ 90 more rows</code></pre>
</div>
<details open=""><summary>Kod</summary><div class="sourceCode" id="cb30"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="co"># predykjca dla optymalnego progu</span></span>
<span><span class="va">pred.optim</span> <span class="op">&lt;-</span> <span class="va">pred</span> <span class="op">|&gt;</span> </span>
<span>  <span class="fu">mutate</span><span class="op">(</span>class <span class="op">=</span> <span class="fu"><a href="https://generics.r-lib.org/reference/coercion-factor.html">as.factor</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/ifelse.html">ifelse</a></span><span class="op">(</span><span class="va">.pred_Yes</span> <span class="op">&gt;</span> <span class="fl">0.19</span>, <span class="st">"Yes"</span>, <span class="st">"No"</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># macierz klasyfikacji</span></span>
<span><span class="va">cm2</span> <span class="op">&lt;-</span> <span class="va">pred.optim</span> <span class="op">|&gt;</span> </span>
<span>  <span class="fu">conf_mat</span><span class="op">(</span>truth <span class="op">=</span> <span class="va">Attrition</span>, estimate <span class="op">=</span> <span class="va">class</span><span class="op">)</span></span>
<span><span class="va">cm2</span></span></code><button title="Kopiuj do schowka" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output cell-output-stdout">
<pre><code>          Truth
Prediction  No Yes
       No  310  20
       Yes  60  52</code></pre>
</div>
<details open=""><summary>Kod</summary><div class="sourceCode" id="cb32"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/summary.html">summary</a></span><span class="op">(</span><span class="va">cm2</span><span class="op">)</span></span></code><button title="Kopiuj do schowka" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output cell-output-stdout">
<pre><code># A tibble: 13 × 3
   .metric              .estimator .estimate
   &lt;chr&gt;                &lt;chr&gt;          &lt;dbl&gt;
 1 accuracy             binary         0.819
 2 kap                  binary         0.458
 3 sens                 binary         0.838
 4 spec                 binary         0.722
 5 ppv                  binary         0.939
 6 npv                  binary         0.464
 7 mcc                  binary         0.475
 8 j_index              binary         0.560
 9 bal_accuracy         binary         0.780
10 detection_prevalence binary         0.747
11 precision            binary         0.939
12 recall               binary         0.838
13 f_meas               binary         0.886</code></pre>
</div>
</div>
</div>
<section id="miary-dopasowania-dla-modeli-ze-zmienną-wynikową-wieloklasową" class="level3" data-number="4.2.1"><h3 data-number="4.2.1" class="anchored" data-anchor-id="miary-dopasowania-dla-modeli-ze-zmienną-wynikową-wieloklasową">
<span class="header-section-number">4.2.1</span> Miary dopasowania dla modeli ze zmienną wynikową wieloklasową</h3>
<p>Wspomniane zostało, że miary dedykowane dla modeli binarnych można również wykorzystać do modeli ze zmienną zależną wielostanową. Oczywiście wówczas trzeba użyć pewnego rodzaju uśredniania. Implementacje wieloklasowe wykorzystują mikro, makro i makro-ważone uśrednianie, a niektóre metryki mają swoje własne wyspecjalizowane implementacje wieloklasowe.</p>
<section id="makro-uśrednianie" class="level4" data-number="4.2.1.1"><h4 data-number="4.2.1.1" class="anchored" data-anchor-id="makro-uśrednianie">
<span class="header-section-number">4.2.1.1</span> Makro uśrednianie</h4>
<p>Makro uśrednianie redukuje wieloklasowe predykcje do wielu zestawów przewidywań binarnych. Oblicza się odpowiednią metrykę dla każdego z przypadków binarnych, a następnie uśrednia wyniki. Jako przykład, rozważmy <em>precision</em>. W przypadku wieloklasowym, jeśli istnieją poziomy A, B, C i D, makro uśrednianie redukuje problem do wielu porównań jeden do jednego. Kolumny <em>truth</em> i <em>estimate</em> są rekodowane tak, że jedynymi dwoma poziomami są A i inne, a następnie <em>precision</em> jest obliczana w oparciu o te rekodowane kolumny, przy czym A jest “wyróżnioną” kolumną. Proces ten jest powtarzany dla pozostałych 3 poziomów, aby uzyskać łącznie 4 wartości precyzji. Wyniki są następnie uśredniane.</p>
<p>Formuła dla <span class="math inline">\(k\)</span> klas wynikowych prezentuje się następująco:</p>
<p><span id="eq-macro"><span class="math display">\[
Pr_{macro} = \frac{Pr_1+Pr_2+\ldots+Pr_k}{k},
\tag{4.15}\]</span></span></p>
<p>gdzie <span class="math inline">\(Pr_i\)</span> oznacza <em>precision</em> dla <span class="math inline">\(i\)</span>-tej klasy.</p>
</section><section id="makro-ważone-uśrednianie" class="level4" data-number="4.2.1.2"><h4 data-number="4.2.1.2" class="anchored" data-anchor-id="makro-ważone-uśrednianie">
<span class="header-section-number">4.2.1.2</span> Makro-ważone uśrednianie</h4>
<p>Makro-ważone uśrednianie jest co do zasady podobne do metody makro uśredniania, z tą jednak zmianą, że wagi poszczególnych czynników w średniej zależą od liczności tych klas, co sprawia, że miara ta jest bardziej optymalna w przypadku wyraźnych dysproporcji zmiennej wynikowej. Formalnie obliczamy to wg reguły:</p>
<p><span id="eq-weightedmacro"><span class="math display">\[
Pr_{weighted-macro}=Pr_1\frac{\#Obs_1}{n}+Pr_2\frac{\#Obs_2}{n}+\ldots+Pr_k\frac{\#Obs_k}{n},
\tag{4.16}\]</span></span></p>
<p>gdzie <span class="math inline">\(\#Obs_i\)</span> oznacza liczbę obserwacji w grupie <span class="math inline">\(i\)</span>-tej, a <span class="math inline">\(n\)</span> jest liczebnością całego zbioru.</p>
</section><section id="mikro-uśrednianie" class="level4" data-number="4.2.1.3"><h4 data-number="4.2.1.3" class="anchored" data-anchor-id="mikro-uśrednianie">
<span class="header-section-number">4.2.1.3</span> Mikro uśrednianie</h4>
<p>Mikro uśrednianie traktuje cały zestaw danych jako jeden wynik zbiorczy i oblicza jedną metrykę zamiast <span class="math inline">\(k\)</span> metryk, które są uśredniane. Dla <em>precision</em> działa to poprzez obliczenie wszystkich <em>true positive</em> wyników dla każdej klasy i użycie tego jako licznika, a następnie obliczenie wszystkich <em>true positive</em> i <em>false positive</em> wyników dla każdej klasy i użycie tego jako mianownika.</p>
<p><span id="eq-micro"><span class="math display">\[
Pr_{micro} = \frac{TP_1+TP_2+\ldots TP_k}{(TP_1+TP_2+\ldots TP_k)+(FP_1+FP_2+\ldots FP_k)}.
\tag{4.17}\]</span></span></p>
<p>W tym przypadku, zamiast klas o równej wadze, mamy obserwacje z równą wagą. Dzięki temu klasy z największą liczbą obserwacji mają największy wpływ na wynik.</p>
<div id="exm-3" class="theorem example">
<p><span class="theorem-title"><strong>Przykład 4.3 </strong></span>Przykład użycia miar dopasowania modelu dla zmiennych wynikowych wieloklasowych.</p>
<div class="cell">
<details open=""><summary>Kod</summary><div class="sourceCode" id="cb34"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="co"># predykcja wykonana dla sprawdzianu krzyżowego</span></span>
<span><span class="co"># bedzie nas interesować tylko wynik pierwszego folda</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/head.html">head</a></span><span class="op">(</span><span class="va">hpc_cv</span><span class="op">)</span></span></code><button title="Kopiuj do schowka" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output cell-output-stdout">
<pre><code>  obs pred        VF          F           M            L Resample
1  VF   VF 0.9136340 0.07786694 0.008479147 1.991225e-05   Fold01
2  VF   VF 0.9380672 0.05710623 0.004816447 1.011557e-05   Fold01
3  VF   VF 0.9473710 0.04946767 0.003156287 4.999849e-06   Fold01
4  VF   VF 0.9289077 0.06528949 0.005787179 1.564496e-05   Fold01
5  VF   VF 0.9418764 0.05430830 0.003808013 7.294581e-06   Fold01
6  VF   VF 0.9510978 0.04618223 0.002716177 3.841455e-06   Fold01</code></pre>
</div>
<details open=""><summary>Kod</summary><div class="sourceCode" id="cb36"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="co"># macierz klasyfikacji</span></span>
<span><span class="va">cm</span> <span class="op">&lt;-</span> <span class="va">hpc_cv</span> <span class="op">|&gt;</span> </span>
<span>  <span class="fu">conf_mat</span><span class="op">(</span>truth <span class="op">=</span> <span class="va">obs</span>, estimate <span class="op">=</span> <span class="va">pred</span><span class="op">)</span></span>
<span><span class="va">cm</span></span></code><button title="Kopiuj do schowka" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output cell-output-stdout">
<pre><code>          Truth
Prediction   VF    F    M    L
        VF 1620  371   64    9
        F   141  647  219   60
        M     6   24   79   28
        L     2   36   50  111</code></pre>
</div>
<details open=""><summary>Kod</summary><div class="sourceCode" id="cb38"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="co"># poniższe miary są makro uśrednione</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/summary.html">summary</a></span><span class="op">(</span><span class="va">cm</span><span class="op">)</span></span></code><button title="Kopiuj do schowka" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output cell-output-stdout">
<pre><code># A tibble: 13 × 3
   .metric              .estimator .estimate
   &lt;chr&gt;                &lt;chr&gt;          &lt;dbl&gt;
 1 accuracy             multiclass     0.709
 2 kap                  multiclass     0.508
 3 sens                 macro          0.560
 4 spec                 macro          0.879
 5 ppv                  macro          0.631
 6 npv                  macro          0.896
 7 mcc                  multiclass     0.515
 8 j_index              macro          0.440
 9 bal_accuracy         macro          0.720
10 detection_prevalence macro          0.25 
11 precision            macro          0.631
12 recall               macro          0.560
13 f_meas               macro          0.570</code></pre>
</div>
<details open=""><summary>Kod</summary><div class="sourceCode" id="cb40"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="co"># poniższe miary są makro uśrednione</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/summary.html">summary</a></span><span class="op">(</span><span class="va">cm</span>, estimator <span class="op">=</span> <span class="st">"micro"</span><span class="op">)</span></span></code><button title="Kopiuj do schowka" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output cell-output-stdout">
<pre><code># A tibble: 13 × 3
   .metric              .estimator .estimate
   &lt;chr&gt;                &lt;chr&gt;          &lt;dbl&gt;
 1 accuracy             multiclass     0.709
 2 kap                  multiclass     0.508
 3 sens                 micro          0.709
 4 spec                 micro          0.903
 5 ppv                  micro          0.709
 6 npv                  micro          0.903
 7 mcc                  multiclass     0.515
 8 j_index              micro          0.612
 9 bal_accuracy         micro          0.806
10 detection_prevalence micro          0.25 
11 precision            micro          0.709
12 recall               micro          0.709
13 f_meas               micro          0.709</code></pre>
</div>
<details open=""><summary>Kod</summary><div class="sourceCode" id="cb42"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="co"># ROC</span></span>
<span><span class="va">hpc_cv</span> <span class="op">|&gt;</span> </span>
<span>  <span class="fu">roc_curve</span><span class="op">(</span>truth <span class="op">=</span> <span class="va">obs</span>, <span class="va">VF</span><span class="op">:</span><span class="va">L</span><span class="op">)</span> <span class="op">|&gt;</span> </span>
<span>  <span class="fu">autoplot</span><span class="op">(</span><span class="op">)</span></span></code><button title="Kopiuj do schowka" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output-display">
<p><img src="measures_files/figure-html/unnamed-chunk-9-1.png" class="img-fluid" width="672"></p>
</div>
<details open=""><summary>Kod</summary><div class="sourceCode" id="cb43"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="co"># AUC</span></span>
<span><span class="va">hpc_cv</span> <span class="op">|&gt;</span> </span>
<span>  <span class="fu">roc_auc</span><span class="op">(</span>truth <span class="op">=</span> <span class="va">obs</span>, <span class="va">VF</span><span class="op">:</span><span class="va">L</span><span class="op">)</span></span></code><button title="Kopiuj do schowka" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output cell-output-stdout">
<pre><code># A tibble: 1 × 3
  .metric .estimator .estimate
  &lt;chr&gt;   &lt;chr&gt;          &lt;dbl&gt;
1 roc_auc hand_till      0.829</code></pre>
</div>
</div>
</div>
</section></section></section><section id="uwagi-końcowe" class="level2" data-number="4.3"><h2 data-number="4.3" class="anchored" data-anchor-id="uwagi-końcowe">
<span class="header-section-number">4.3</span> Uwagi końcowe</h2>
<p>Stosując jedna miarę dopasowania modelu (bez względu na to czy jest to model klasyfikacyjny czy regresyjny) możemy nie otrzymać optymalnego modelu. Ze względu na definicje miary dopasowania różnią się pomiędzy sobą eksponując nieco inne aspekty. To powoduje, że może się zdarzyć sytuacja, że optymalny model ze względu na <span class="math inline">\(R^2\)</span> będzie się różnił (nawet znacznie) od modelu optymalizowanego z użyciem RMSE (patrz <a href="#fig-por">Rysunek&nbsp;<span>4.4</span></a>).</p>
<div id="fig-por" class="quarto-figure quarto-figure-center anchored">
<figure class="figure"><p><img src="images/Zrzut ekranu 2023-02-20 o 17.08.24.png" class="img-fluid figure-img"></p>
<p></p><figcaption class="figure-caption">Rysunek&nbsp;4.4: Porównanie jakości modeli z wykorzystaniem różnych miar</figcaption><p></p>
</figure>
</div>
<p>Model zoptymalizowany pod kątem RMSE ma większą zmienność, ale ma stosunkowo jednolitą dokładność w całym zakresie wyników. Prawy panel pokazuje, że istnieje silniejsza korelacja między wartościami obserwowanymi i przewidywanymi, ale model ten słabo radzi sobie w przewidywaniu skrajnych wartości. Na marginesie można dodać, że jeśli model miałby być stosowany do predykcji (co zdarza się bardzo często w modelach ML), to miara RMSE jest lepsza, natomiast gdy interesują nas poszczególne efekty modelu regresji, wówczas <span class="math inline">\(R^2\)</span> jest częściej stosowaną miarą oceny dopasowania modelu.</p>
<p>Podobny przykład można przytoczyć również dla modeli klasyfikacyjnych.</p>
<p>Ocena skuteczności danego modelu zależy od tego, do czego będzie on wykorzystywany. Model inferencyjny jest używany przede wszystkim do zrozumienia związków i zazwyczaj kładzie nacisk na wybór (i ważność) rozkładów probabilistycznych i innych cech generatywnych, które definiują model. Dla modelu używanego głównie do przewidywania, w przeciwieństwie do tego, siła predykcyjna ma podstawowe znaczenie, a inne obawy dotyczące podstawowych właściwości statystycznych mogą być mniej ważne. Siła predykcyjna jest zwykle określana przez to, jak blisko nasze przewidywania zbliżają się do obserwowanych danych, tj. wierność przewidywań modelu do rzeczywistych wyników. W tym rozdziale skupiono się na funkcjach, które można wykorzystać do pomiaru siły predykcji. Jednakże naszą radą dla osób opracowujących modele inferencyjne jest stosowanie tych technik nawet wtedy, gdy model nie będzie używany z głównym celem przewidywania.</p>
<p>Od dawna problemem w praktyce statystyki inferencyjnej jest to, że skupiając się wyłącznie na wnioskowaniu, trudno jest ocenić wiarygodność modelu. Na przykład, rozważ dane dotyczące choroby Alzheimera z <span class="citation" data-cites="Craig-Schapiro2011">Craig-Schapiro i in. (<a href="references.html#ref-Craig-Schapiro2011" role="doc-biblioref">2011</a>)</span>, gdzie 333 pacjentów było badanych w celu określenia czynników wpływających na upośledzenie funkcji poznawczych. W analizie można uwzględnić znane czynniki ryzyka i zbudować model regresji logistycznej, w którym wynik jest binarny (upośledzony/nieupośledzony). Rozważmy predyktory wieku, płci i genotypu apolipoproteiny E. Ta ostatnia jest zmienną kategoryczną zawierającą sześć możliwych kombinacji trzech głównych wariantów tego genu. Wiadomym jest, że apolipoproteina E ma związek z demencją <span class="citation" data-cites="Kim2009">(<a href="references.html#ref-Kim2009" role="doc-biblioref">Kim, Basak, i Holtzman 2009</a>)</span>.</p>
<p>Powierzchowne, ale nierzadkie podejście do tej analizy polegałoby na dopasowaniu dużego modelu z głównymi efektami i interakcjami, a następnie zastosowaniu testów statystycznych w celu znalezienia minimalnego zestawu efektów modelu, które są statystycznie istotne na jakimś wcześniej zdefiniowanym poziomie. Jeśli użyto pełnego modelu z trzema czynnikami i ich dwu- i trójstronnymi interakcjami, wstępnym etapem byłoby przetestowanie interakcji przy użyciu sekwencyjnych testów ilorazu prawdopodobieństwa <span class="citation" data-cites="hosmer2000">(<a href="references.html#ref-hosmer2000" role="doc-biblioref">Hosmer i Lemeshow 2000</a>)</span>. Przejdźmy przez takie podejście dla przykładowych danych dotyczących choroby Alzheimera:</p>
<ul>
<li>Porównując model ze wszystkimi interakcjami dwukierunkowymi z modelem z dodatkową interakcją trójkierunkową, testy ilorazu wiarygodności dają wartość <span class="math inline">\(p\)</span> równą 0,888. Oznacza to, że nie ma dowodów na to, że cztery dodatkowe terminy modelu związane z interakcją trójkierunkową wyjaśniają wystarczająco dużo zmienności w danych, aby zachować je w modelu.</li>
<li>Następnie, dwukierunkowe interakcje są podobnie oceniane w stosunku do modelu bez interakcji. Wartość <span class="math inline">\(p\)</span> wynosi tutaj 0,0382. Biorąc pod uwagę niewielki rozmiar próbki, byłoby rozsądnie stwierdzić, że istnieją dowody na to, że niektóre z 10 możliwych dwukierunkowych interakcji są ważne dla modelu.</li>
<li>Na tej podstawie wyciągnęlibyśmy pewne wnioski z uzyskanych wyników. Interakcje te byłyby szczególnie ważne do omówienia, ponieważ mogą one zapoczątkować interesujące fizjologiczne lub neurologiczne hipotezy, które należy dalej badać.</li>
</ul>
<p>Chociaż jest to strategia uproszczona, jest ona powszechna zarówno w praktyce, jak i w literaturze. Jest to szczególnie częste, jeśli praktykujący ma ograniczone formalne wykształcenie w zakresie analizy danych.</p>
<p>Jedną z brakujących informacji w tym podejściu jest to, jak blisko model ten pasuje do rzeczywistych danych. Stosując metody resamplingu, omówione w rozdziale 10, możemy oszacować dokładność tego modelu na około 73,4%. Dokładność jest często słabą miarą wydajności modelu; używamy jej tutaj, ponieważ jest powszechnie rozumiana. Jeśli model ma 73,4% dokładności w stosunku do danych, to czy powinniśmy zaufać wnioskom, które produkuje? Moglibyśmy tak myśleć, dopóki nie zdamy sobie sprawy, że wskaźnik bazowy nieupośledzonych pacjentów w danych wynosi 72,7%. Oznacza to, że pomimo naszej analizy statystycznej, model dwuczynnikowy okazuje się być tylko o 0,8% lepszy od prostej heurystyki, która zawsze przewiduje, że pacjenci nie są upośledzeni, niezależnie od obserwowanych danych.</p>


<div id="refs" class="references csl-bib-body hanging-indent" role="list" style="display: none">
<div id="ref-EvaluatingForecastAccuracy" class="csl-entry" role="listitem">
<em>3.4 <span>Evaluating</span> Forecast Accuracy | <span>Forecasting</span>: <span>Principles</span> and <span>Practice</span> (2nd Ed)</em>. b.d.
</div>
<div id="ref-bellon-maurelCriticalReviewChemometric2010" class="csl-entry" role="listitem">
Bellon-Maurel, Véronique, Elvira Fernandez-Ahumada, Bernard Palagos, Jean-Michel Roger, i Alex McBratney. 2010. <span>„Critical Review of Chemometric Indicators Commonly Used for Assessing the Quality of the Prediction of Soil Attributes by <span>NIR</span> Spectroscopy”</span>. <em>TrAC Trends in Analytical Chemistry</em> 29 (9): 1073–81. <a href="https://doi.org/10.1016/j.trac.2010.05.006">https://doi.org/10.1016/j.trac.2010.05.006</a>.
</div>
<div id="ref-Craig-Schapiro2011" class="csl-entry" role="listitem">
Craig-Schapiro, Rebecca, Max Kuhn, Chengjie Xiong, Eve H. Pickering, Jingxia Liu, Thomas P. Misko, Richard J. Perrin, i in. 2011. <span>„Multiplexed Immunoassay Panel Identifies Novel CSF Biomarkers for Alzheimer’s Disease Diagnosis and Prognosis”</span>. Zredagowane przez Ashley I. Bush. <em>PLoS ONE</em> 6 (4): e18850. <a href="https://doi.org/10.1371/journal.pone.0018850">https://doi.org/10.1371/journal.pone.0018850</a>.
</div>
<div id="ref-fransesNoteMeanAbsolute2016" class="csl-entry" role="listitem">
Franses, Philip Hans. 2016. <span>„A Note on the <span>Mean Absolute Scaled Error</span>”</span>. <em>International Journal of Forecasting</em> 32 (1): 20–22. <a href="https://doi.org/10.1016/j.ijforecast.2015.03.008">https://doi.org/10.1016/j.ijforecast.2015.03.008</a>.
</div>
<div id="ref-hosmer2000" class="csl-entry" role="listitem">
Hosmer, David W., i Stanley Lemeshow. 2000. <em>Applied Logistic Regression</em>. John Wiley &amp; Sons, Inc. <a href="https://doi.org/10.1002/0471722146">https://doi.org/10.1002/0471722146</a>.
</div>
<div id="ref-hyndmanAnotherLookMeasures2006" class="csl-entry" role="listitem">
Hyndman, Rob J., i Anne B. Koehler. 2006. <span>„Another Look at Measures of Forecast Accuracy”</span>. <em>International Journal of Forecasting</em> 22 (4): 679–88. <a href="https://doi.org/10.1016/j.ijforecast.2006.03.001">https://doi.org/10.1016/j.ijforecast.2006.03.001</a>.
</div>
<div id="ref-Kim2009" class="csl-entry" role="listitem">
Kim, Jungsu, Jacob M. Basak, i David M. Holtzman. 2009. <span>„The Role of Apolipoprotein E in Alzheimer’s Disease”</span>. <em>Neuron</em> 63 (3): 287–303. <a href="https://doi.org/10.1016/j.neuron.2009.06.026">https://doi.org/10.1016/j.neuron.2009.06.026</a>.
</div>
<div id="ref-kvalsethCautionaryNoteR21985" class="csl-entry" role="listitem">
Kvalseth, Tarald O. 1985. <span>„Cautionary <span>Note</span> about <span>R2</span>”</span>. <em>The American Statistician</em> 39 (4): 279–85. <a href="https://doi.org/10.2307/2683704">https://doi.org/10.2307/2683704</a>.
</div>
<div id="ref-yehAnalysisStrengthConcrete2006" class="csl-entry" role="listitem">
Yeh, I.-Cheng. 2006. <span>„Analysis of <span>Strength</span> of <span>Concrete Using Design</span> of <span>Experiments</span> and <span>Neural Networks</span>”</span>. <em>Journal of Materials in Civil Engineering</em> 18 (4): 597–604. <a href="https://doi.org/10.1061/(ASCE)0899-1561(2006)18:4(597)">https://doi.org/10.1061/(ASCE)0899-1561(2006)18:4(597)</a>.
</div>
</div>
</section></main><!-- /main --><script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  let localAlternateSentinel = 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Skopiowano!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Skopiowano!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script><nav class="page-navigation"><div class="nav-page nav-page-previous">
      <a href="./infer.html" class="pagination-link">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Modele inferencyjne</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./resampling.html" class="pagination-link">
        <span class="nav-page-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Zarządzanie danymi</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->
<footer class="footer"><div class="nav-footer">
    <div class="nav-footer-left">Metody walidacji modeli statystycznych, Dariusz Majerek</div>   
    <div class="nav-footer-center">
      &nbsp;
    </div>
    <div class="nav-footer-right">Książka została napisana w <a href="https://quarto.org/">Quarto</a></div>
  </div>
</footer>


</body></html>